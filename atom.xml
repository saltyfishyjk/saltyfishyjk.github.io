<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>saltyfishyjk&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ec4fcb8d6405f66b3dc46fd5a289e5a9</icon>
  <subtitle>我会珍惜这一份幸运</subtitle>
  <link href="https://saltyfishyjk.github.io/atom.xml" rel="self"/>
  
  <link href="https://saltyfishyjk.github.io/"/>
  <updated>2025-03-11T16:09:46.000Z</updated>
  <id>https://saltyfishyjk.github.io/</id>
  
  <author>
    <name>saltyfishyjk</name>
    <email>yjk_official@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring笔记</title>
    <link href="https://saltyfishyjk.github.io/2025/03/11/Spring%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2025/03/11/Spring%E7%AC%94%E8%AE%B0/</id>
    <published>2025-03-11T15:13:51.000Z</published>
    <updated>2025-03-11T16:09:46.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>DNS笔记</title>
    <link href="https://saltyfishyjk.github.io/2024/11/10/DNS%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2024/11/10/DNS%E7%AC%94%E8%AE%B0/</id>
    <published>2024-11-10T13:18:47.000Z</published>
    <updated>2025-03-28T08:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS笔记"><a href="#DNS笔记" class="headerlink" title="DNS笔记"></a>DNS笔记</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>记录文献中学习到的 DNS 相关基础知识。</p><h2 id="Part-1-基本概念"><a href="#Part-1-基本概念" class="headerlink" title="Part 1 基本概念"></a>Part 1 基本概念</h2><h3 id="DNS-解析参与方"><a href="#DNS-解析参与方" class="headerlink" title="DNS 解析参与方"></a>DNS 解析参与方</h3><h4 id="客户端-DNS-Client-stub-resolver"><a href="#客户端-DNS-Client-stub-resolver" class="headerlink" title="客户端 DNS Client(stub resolver)"></a>客户端 DNS Client(stub resolver)</h4><p>发送一个请求到recursive resolver，使其作为代理代为查询。</p><h4 id="（递归）解析器-DNS-Recursive-resolver"><a href="#（递归）解析器-DNS-Recursive-resolver" class="headerlink" title="（递归）解析器 DNS Recursive resolver"></a>（递归）解析器 DNS Recursive resolver</h4><p>也叫递归侧/resolver。</p><p>接收从 client 发来的 DNS query，从 Root Nameserver 开始逐级查询。</p><p>四种不同模式：</p><ul><li>标准模式（recursive-only）：递归查询</li><li>转发器（forwarder）：此时 resolver 作为转发器，将 query 转发给上游 recursive resolver，使其代为查询</li><li>条件DNS（condiotional DNS, CDNS）：同时有 recursive 和 forwarder 两种模式，各有一个 DNS namespace 子空间，根据特定域名或客户端 IP 等进行选择性转发<ul><li>CDNS without fallback：没有备用选项，上游 resolver 可能不可用</li><li>CDNS with fallback：当上游 resolver 不可用时，系统使用备用的 resolver 保证请求可以被解析</li></ul></li></ul><h4 id="名称服务器-DNS-Nameserver"><a href="#名称服务器-DNS-Nameserver" class="headerlink" title="名称服务器 DNS Nameserver"></a>名称服务器 DNS Nameserver</h4><p>也叫权威侧/Nameserver/Server。</p><h5 id="ROOT"><a href="#ROOT" class="headerlink" title="ROOT"></a>ROOT</h5><p>根服务器，返回参考应答（ref-response），这是一种包含<strong>进一步的指向信息</strong>，而不包含所需的 IP 地址的响应。</p><h5 id="TLD"><a href="#TLD" class="headerlink" title="TLD"></a>TLD</h5><p>Top-Level Domain，如 .com, .net 等，返回 ref-response</p><h5 id="SLD"><a href="#SLD" class="headerlink" title="SLD"></a>SLD</h5><p>Second-Level Domain，如 cnn.com 等，（可能）返回权威应答（auth-response），包含<strong>最终 IP 地址</strong>的权威响应。</p><h3 id="资源记录-RR"><a href="#资源记录-RR" class="headerlink" title="资源记录 RR"></a>资源记录 RR</h3><p>RR, resource record，定义为五元组：</p><script type="math/tex; mode=display"><owner, type, class, TTL, RDATA></script><ul><li>$owner$：（RR）所有者，表明该 RR 属于哪个域名</li><li>$type$：类型，表明该 RR 的类型，常见的如 A（IPv4地址记录）、MX、CNAME（域名别名）、NS（名称服务器）</li><li>$Class$：类别，表明 RR 的上下文，IN 表示 Internet 最常见</li><li>$TTL$：Time to Live，表明 RR 可以在 DNS 缓存中存在的时间，单位为秒</li><li>$RDATA$：数据，类型取决于 $type$</li></ul><h4 id="信任等级"><a href="#信任等级" class="headerlink" title="信任等级"></a>信任等级</h4><p>DNS 软件通过 RR 的信任等级来决定是否返回给用户、保存到内存或更新已有数据。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="image-20241111164851486.png" alt="image-20241111164851486"></p><blockquote><p>[Usenix Security ‘24]{CAMP}: Compositional Amplification Attacks against {DNS}</p></blockquote><p>NS, CNAME, DNAME, SOA, A, AAAA</p><h4 id="NS-Name-Server"><a href="#NS-Name-Server" class="headerlink" title="NS(Name Server)"></a>NS(Name Server)</h4><p>NS记录，指定一个域名的权威 DNS 服务器</p><h4 id="CNAME-Canonical-Name"><a href="#CNAME-Canonical-Name" class="headerlink" title="CNAME(Canonical Name)"></a>CNAME(Canonical Name)</h4><p>别名记录，将一个域名（别名）永久重定向到另一个域名（规范名称）。</p><p>一个域名只应该有一个 CNAME[USENIX ‘24 CAMP]。</p><h4 id="DNAME-Delegation-Name"><a href="#DNAME-Delegation-Name" class="headerlink" title="DNAME(Delegation Name)"></a>DNAME(Delegation Name)</h4><p>委托记录，实现域名的递归重定向，将一个域名的整个子域重定向到另一个域名，如 sub.example.com 有一个 DNAME 记录指向 sub.newdomain.com，则任何 sub.example.com 或其子域（如sub.example.com/path）的查询会重定向到 sub.newdomain.com或相应的子域（如sub.newdomain.com/path）</p><p>一个域名只应该有一个 DNAME[USENIX ‘24 CAMP]。</p><h4 id="RRSIG"><a href="#RRSIG" class="headerlink" title="RRSIG"></a>RRSIG</h4><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><h4 id="引用响应-Ref-response"><a href="#引用响应-Ref-response" class="headerlink" title="引用响应 Ref-response"></a>引用响应 Ref-response</h4><p>Ref-response, referral response，由 NS 向 resolver 返回的包含指示下一步向谁发送 query 的响应。</p><h4 id="权威响应-Auth-response"><a href="#权威响应-Auth-response" class="headerlink" title="权威响应 Auth-response"></a>权威响应 Auth-response</h4><p>Auth-response, authoritative response, 由 NS 向 resolver 返回的包含最终结果（IP）的响应，解析结束。</p><h3 id="bailiwick"><a href="#bailiwick" class="headerlink" title="bailiwick"></a>bailiwick</h3><h4 id="in-bailiwick"><a href="#in-bailiwick" class="headerlink" title="in-bailiwick"></a>in-bailiwick</h4><h4 id="out-of-bailiwick"><a href="#out-of-bailiwick" class="headerlink" title="out-of-bailiwick"></a>out-of-bailiwick</h4><h2 id="Part-2-解析流程"><a href="#Part-2-解析流程" class="headerlink" title="Part 2 解析流程"></a>Part 2 解析流程</h2><p><img src="image-20241110220821395.png" alt="image-20241110220821395"></p><blockquote><p>[Usenix Security ‘24]{ResolverFuzz}: Automated Discovery of {DNS} Resolver Vulnerabilities with {Query-Response} Fuzzing</p></blockquote><ol><li>Client 发起一个 Client-query $Q$</li><li>Recursive resolver 收到 $Q$，并作为代理，向 ROOT Nameserver 发送 Resolver-query $Q_R$</li><li>ROOT Nameserver 收到 $Q_R$，其根区域文件（root zone）中只包含 TLD 权威服务器的地址，因此向 Recursive resolver 返回一个 ref-response $R_R$，包含 TLD 的 NS 记录以及其 IP 地址</li><li>Recursive resolver 收到 $R_R$ ，向 TLD 发送一个 $Q_R$</li><li>TLD Nameserver 收到 $Q_R$，其 zone file 包含 SLD 的 NS 记录机器 IP 地址，将 $R_R$ 返回</li><li>Recursive resolver 收到 $R_R$，向 SLD 发送一个 $Q_R$</li><li>SLD Nameserver 收到 $Q_R$，其为被查询域名的权威名称服务器，包含具体的 NS 和 对应的 IP 地址，因此返回的是权威响应 $R_A$</li><li>Recursive resolver 收到 $R_A$，包含了域名对应的 IP 地址，递归查询结束，将结果 $R$ 返回给 Client</li></ol><h2 id="Part-3-胶水记录-Glue-Record"><a href="#Part-3-胶水记录-Glue-Record" class="headerlink" title="Part 3 胶水记录 Glue Record"></a>Part 3 胶水记录 Glue Record</h2><p>胶水记录是 DNS zone 中的一种 A 记录，在 RFC 1034 中记录。</p><h2 id="Part-4-攻击"><a href="#Part-4-攻击" class="headerlink" title="Part 4 攻击"></a>Part 4 攻击</h2><h3 id="反射攻击-Reflective-attack"><a href="#反射攻击-Reflective-attack" class="headerlink" title="反射攻击 Reflective attack"></a>反射攻击 Reflective attack</h3><p>攻击者伪造目标 IP 地址，发送信息请求，使得服务器响应请求并将答复发送给目标 IP 地址。</p><h3 id="放大攻击-Amplification-attack"><a href="#放大攻击-Amplification-attack" class="headerlink" title="放大攻击 Amplification attack"></a>放大攻击 Amplification attack</h3><p>利用脆弱服务对攻击者发送的请求做出大量回复，引起比原始请求大得多的响应。</p><h2 id="Part-5-权威侧垂直结构"><a href="#Part-5-权威侧垂直结构" class="headerlink" title="Part 5 权威侧垂直结构"></a>Part 5 权威侧垂直结构</h2><p><img src="image-20241113205257618.png" alt="image-20241113205257618"></p><blockquote><p>[Usenix Security ‘24]Rethinking the Security Threats of Stale DNS Glue Records</p></blockquote><p>域名空间 Domain name space  是树状结构，其中的每个节点 node 或叶子 leaf 都和一个资源集相关联，比其高的区域 zone 是父区域 parent zone，比其低的区域是子区域 child zone。</p><ul><li>最顶层：根区域 root zone <code>.</code></li><li>Top-Level Domains：TLD，如 <code>.com</code>、<code>.net</code></li><li>Second-Level Domains：SLD，如<code>exam.com</code>、<code>foo.com</code></li></ul><p>一个 DNS zone 只包含其子域的信息。如图所示，对于请求②，根返回一个 ref-response③，告知 resolver 关于 <code>.com</code> 的权威 nameserver 的信息；对于请求④，<code>.com</code> nameserver 返回一个 ref-response⑤，告知关于 <code>exam.com</code> 的权威 nameserver 的信息；对于请求⑥，<code>exam.com</code> nameserver 最终返回了 <code>exam.com</code> 的资源记录。</p><h2 id="Part-6-域名授权（委托）-Domain-delegation"><a href="#Part-6-域名授权（委托）-Domain-delegation" class="headerlink" title="Part 6 域名授权（委托） Domain delegation"></a>Part 6 域名授权（委托） Domain delegation</h2><p>域名管理者通过配置委托 NS 记录和胶水记录（如需）来将其域名委托给特定的服务器。根据 NS 记录和域名的关系，共有三种授权类型：in-domain, sibling-domain 和 out-domain。</p><blockquote><p>[Usenix Security ‘24]Rethinking the Security Threats of Stale DNS Glue Records</p></blockquote><h3 id="域内委托-in-domain"><a href="#域内委托-in-domain" class="headerlink" title="域内委托 in-domain"></a>域内委托 in-domain</h3><p>NS 记录配置了包含在被委托域名内的 nameserver，这种情况下<strong>胶水记录是必需的</strong>。</p><p><img src="image-20241116213748947.png" alt="image-20241116213748947"></p><p>图中 test.com 的 NS 记录是 ns1.test.com，在 test.com 中，需要胶水记录打破循环。</p><h3 id="兄弟域委托-sibling-domain"><a href="#兄弟域委托-sibling-domain" class="headerlink" title="兄弟域委托 sibling-domain"></a>兄弟域委托 sibling-domain</h3><p>NS 记录没有配置在被委托域名下，但是在另一个同一父域委派的区域中，<strong>胶水记录不是必需的</strong>。</p><p><img src="image-20241116213857202.png" alt="image-20241116213857202"></p><p>图中 test.com 的 NS 记录是 ns1.foo.com，不在 test.com 中，而是在 foo.com 中，而 foo.com 的父域是 .com，和 test.com 是同一父域。尽管这种情况下胶水记录不是必需的，resolver 返回的 ref-response 一般也包含该记录。</p><h3 id="域外委托-out-domain"><a href="#域外委托-out-domain" class="headerlink" title="域外委托 out-domain"></a>域外委托 out-domain</h3><p>NS 记录配置的 nameserver 跨越了 TLD，<strong>胶水记录不是必需的</strong>。</p><p><img src="image-20241116214842279.png" alt="image-20241116214842279"></p><p>图中 test.com 的 NS 记录是 ns1.test.net，其 TLD 是 .net，和 test.com 的 TLD .com 不是一个。对于这种情况，resolver 返回的 ref-response 不应该包含胶水记录，应该重新对 ns1.test.net 发起主动解析。</p><h2 id="Part-7-DNS-机制"><a href="#Part-7-DNS-机制" class="headerlink" title="Part 7 DNS 机制"></a>Part 7 DNS 机制</h2><h3 id="超时重传-timeout"><a href="#超时重传-timeout" class="headerlink" title="超时重传 timeout"></a>超时重传 timeout</h3><p>DNS 经典依赖的协议是 UDP，这是一种无状态的协议，即本身缺少送达承诺或者重传机制。DNS 为了提高可用性采取了 timeout 机制，确保 DNS 解析功能。</p><p><img src="image-20241117111203774.png" alt="image-20241117111203774"></p><blockquote><p>[S&amp;P ‘24]DNSBomb: A New Practical-and-Powerful Pulsing DoS Attack Exploiting DNS Queries-and-Responses</p></blockquote><ul><li><p>4-a：timeout 机制包括请求和响应两种。</p></li><li><p>4-b：请求 timeout 会指定一个最长的 resolver 对 DNS server 等待响应的时间，在这之后会认为这个请求超时。当 resolver 向 DNS server 发送一个请求时，会设定一个计时器 timer，BIND 默认为 800ms。当超时后还没有收到响应时，resolver 会使用一个更新的计时器重发请求（可能向不同的 nameserver），或者终止这个请求。</p></li><li>4-c：为了避免无限重试，一般会设置重试次数上限，对 Unbound 是11。当超时且没有得到响应时，resolver 会返回一个 ServFail 错误。</li></ul><h3 id="DNS-请求聚合"><a href="#DNS-请求聚合" class="headerlink" title="DNS 请求聚合"></a>DNS 请求聚合</h3><p>将多个</p><p><img src="image-20241117152549851.png" alt="image-20241117152549851"></p><blockquote><p>[S&amp;P ‘24]DNSBomb: A New Practical-and-Powerful Pulsing DoS Attack Exploiting DNS Queries-and-Responses</p></blockquote><ul><li>5-a：没有 DNS 聚合机制<ul><li>对每个 client 发来的请求，resolver 都向权威 nameserver 查询</li></ul></li><li>5-b：有 DNS 聚合机制<ul><li>对每个 client 发来的请求，如果域名相同，那么仅向权威 nameserver 查询 1 次</li></ul></li></ul><h2 id="Part-8-IP-分片"><a href="#Part-8-IP-分片" class="headerlink" title="Part 8 IP 分片"></a>Part 8 IP 分片</h2><h2 id="Part-9-Resolver-分类"><a href="#Part-9-Resolver-分类" class="headerlink" title="Part 9 Resolver 分类"></a>Part 9 Resolver 分类</h2><h3 id="开放解析器-open-resolver"><a href="#开放解析器-open-resolver" class="headerlink" title="开放解析器 open resolver"></a>开放解析器 open resolver</h3><p>分布在互联网中，任何地址都可以向其发送 DNS 请求</p><h3 id="服务有限网络的-resolver"><a href="#服务有限网络的-resolver" class="headerlink" title="服务有限网络的 resolver"></a>服务有限网络的 resolver</h3><p>分布在家中或者企业网络中，攻击者可以通过收集大规模网络测量平台的优势点 vantage point 或者使用家用代理网络来向其生成 DNS 请求</p><h3 id="客户端解析器-stub-resolver"><a href="#客户端解析器-stub-resolver" class="headerlink" title="客户端解析器 stub resolver"></a>客户端解析器 stub resolver</h3><p>客户端解析器，不直接查询 DNS 请求，而是将其发给本地的递归解析器执行请求</p><p>攻击者可以通过嵌入攻击者控制域名的在线广告或垃圾邮件来引导客户端发起 DNS 查询请求</p><h2 id="Part-10-DNSSEC"><a href="#Part-10-DNSSEC" class="headerlink" title="Part 10 DNSSEC"></a>Part 10 DNSSEC</h2><blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/355579999">DNSSEC？禁止套娃！-知乎</a></p></blockquote><p>DNSSEC 保证了 DNS 中的源真实性（origin authenticity）和数据完整性（data integrity）。</p><ul><li>使用私钥对 RRsets 签名以验证权威性和完整性</li><li>签名在 DNS 中发布，即为 RRSIG</li><li>DNSKEY 公钥也发布从而使得 RRSIG 可以被验证</li><li>子区域也使用其私钥对其记录进行签名</li><li>父区域对子区域的 DS 记录签名来证明权威性</li></ul><p><img src="image-20241202192742295.png" alt="image-20241202192742295"></p><h3 id="权威侧-server"><a href="#权威侧-server" class="headerlink" title="权威侧 server"></a>权威侧 server</h3><ul><li>为 zone 签名</li><li>向请求回答所需的记录</li><li>同事发送和记录相关联的数字签名</li></ul><h3 id="递归侧-resolver-验证"><a href="#递归侧-resolver-验证" class="headerlink" title="递归侧 resolver 验证"></a>递归侧 resolver 验证</h3><ul><li>验证来自 server 的响应</li><li>对无效的结果返回 SERVFAIL</li></ul><h3 id="DNSKEY"><a href="#DNSKEY" class="headerlink" title="DNSKEY"></a>DNSKEY</h3><p>一种资源记录，包含区域的<strong>公钥</strong>，使用公钥密码学来签发和验证 RRsets 。每个区域会使用两种 DNSKEY 来为 DNS 记录签名</p><p><img src="image-20241202192950254.png" alt="image-20241202192950254"></p><h4 id="ZSK-Zone-Signing-Key"><a href="#ZSK-Zone-Signing-Key" class="headerlink" title="ZSK, Zone-Signing-Key"></a>ZSK, Zone-Signing-Key</h4><ul><li>为区域中的 RRSets 签名</li><li>被 KSK 签名</li><li>使用 flag 256</li></ul><p>ZSK 用于为区域中的（其他，DNSKEY之外的）记录签名，使用 KSK 进行身份验证。</p><h4 id="KSK-Key-Signing-Key"><a href="#KSK-Key-Signing-Key" class="headerlink" title="KSK, Key-Signing-Key"></a>KSK, Key-Signing-Key</h4><ul><li>为 ZSK 签名</li><li>指向父区域</li><li>为 DNSKEY 记录生成 RRSIG</li></ul><h3 id="RRSIG-1"><a href="#RRSIG-1" class="headerlink" title="RRSIG"></a>RRSIG</h3><p>RRSIG, <strong>R</strong>esource <strong>R</strong>ecord <strong>SIG</strong>nature</p><ul><li>RRSIG和记录集合（RRset）相关联，包括 name, class, record type。</li><li>对特定 name 的给定 type 的所有记录的签名<ul><li>如，对 example.org 的 A 记录的签名形成一个 RRSIG：example.org A RRSIG</li></ul></li><li>RRSIG 是由一个和 DNSKEY 中公钥对应的私钥创造的</li></ul><p><img src="image-20241202184724494.png" alt="image-20241202184724494"></p><h3 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h3><p>DS, <strong>D</strong>elegation <strong>S</strong>igner</p><p>一种资源记录，本质上是 DNSKEY 的哈希，这些记录被上传到父区域，从而建立了到达根区域的信任链。父区域的 DS 记录和其他记录一样都是使用 RRSIG 验证的。</p><h2 id="Part-11-Bind"><a href="#Part-11-Bind" class="headerlink" title="Part 11 Bind"></a>Part 11 Bind</h2><p>Bind9是流行的DNS软件，可以用作递归解析器或者权威服务器。</p><h3 id="从源码安装特定版本Bind"><a href="#从源码安装特定版本Bind" class="headerlink" title="从源码安装特定版本Bind"></a>从源码安装特定版本Bind</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>使用 <code>./named -c /etc/bind/name.conf -g</code>来调试运行bind</p><h3 id="设置A记录"><a href="#设置A记录" class="headerlink" title="设置A记录"></a>设置A记录</h3><blockquote><p>下述以twitter.com为例</p></blockquote><ol><li><p>确认区域文件位置</p><ul><li>在<code>/etc/bind/named.conf</code>中查看区域文件配置</li><li>（一般）在<code>/etc/bind/named.conf.local</code>中查看区域文件具体位置，一般是<code>/etc/bind/named.conf.zones</code></li><li>在<code>/etc/bind/named.conf.zones</code>中查看域名区域文件位置，一般是<code>/etc/bind/zones/twitter.com.</code></li></ul></li><li><p>编辑区域文件</p><ul><li><p>编辑<code>/etc/bind/zones/twitter.com.</code></p></li><li><p>添加A记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ A 10.161.0.7</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重启bind9生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/named restart</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>正确的<code>twitter.com</code>区域文件示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$TTL 300</span><br><span class="line">$ORIGIN twitter.com.</span><br><span class="line">@ SOA ns1.twitter.com. admin.twitter.com. 3418864001 900 900 1800 60</span><br><span class="line">;ns1.twitter.com. A 10.161.0.71</span><br><span class="line">@ NS ns1.twitter.com.</span><br><span class="line">ns1 A 10.161.0.71</span><br><span class="line">@ A 10.161.0.71</span><br></pre></td></tr></table></figure></li></ol><h2 id="Part-12-Unbound"><a href="#Part-12-Unbound" class="headerlink" title="Part 12 Unbound"></a>Part 12 Unbound</h2><p>Unbound一般用作递归解析器，不用做权威服务器。</p><h3 id="设置root-hints"><a href="#设置root-hints" class="headerlink" title="设置root.hints"></a>设置<code>root.hints</code></h3><ol><li><p>确认<code>root.hints</code>位置</p><ul><li>可能在<code>/etc/unbound/root.hints</code></li></ul></li><li><p>确认内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. 3600 IN NS ns1.</span><br><span class="line">ns1. 3600 IN A 10.171.0.71</span><br><span class="line"></span><br><span class="line">;ns1. A 10.171.0.71</span><br><span class="line">;. NS ns1.</span><br></pre></td></tr></table></figure><blockquote><p>前两行是正确的，后两行是错误的</p></blockquote></li></ol><h3 id="配置关闭DNSSEC"><a href="#配置关闭DNSSEC" class="headerlink" title="配置关闭DNSSEC"></a>配置关闭DNSSEC</h3><p>在<code>/etc/unbound/unbound.conf</code>中添加字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val-permissive-mode: yes</span><br></pre></td></tr></table></figure><h2 id="Part-13-PowerDNS"><a href="#Part-13-PowerDNS" class="headerlink" title="Part 13 PowerDNS"></a>Part 13 PowerDNS</h2><h2 id="Part-14-dig"><a href="#Part-14-dig" class="headerlink" title="Part 14 dig"></a>Part 14 dig</h2><h3 id="dig-trace-example-com"><a href="#dig-trace-example-com" class="headerlink" title="dig +trace example.com"></a><code>dig +trace example.com</code></h3><p>可以看响应路径</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DNS笔记&quot;&gt;&lt;a href=&quot;#DNS笔记&quot; class=&quot;headerlink&quot; title=&quot;DNS笔记&quot;&gt;&lt;/a&gt;DNS笔记&lt;/h1&gt;&lt;h2 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="DNS" scheme="https://saltyfishyjk.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>TLS笔记</title>
    <link href="https://saltyfishyjk.github.io/2024/04/07/TLS%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2024/04/07/TLS%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-07T14:03:29.000Z</published>
    <updated>2024-04-08T02:00:14.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>NSQ笔记</title>
    <link href="https://saltyfishyjk.github.io/2024/04/05/NSQ%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2024/04/05/NSQ%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-05T03:07:49.000Z</published>
    <updated>2024-07-18T08:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NSQ笔记"><a href="#NSQ笔记" class="headerlink" title="NSQ笔记"></a>NSQ笔记</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p><a href="https://nsq.io/">NSQ</a> 是一种实时分布式消息（队列）平台，提供 Go 的官方版本。</p><p>参考资料：</p><ul><li><a href="https://nsq.io/">NSQ 官网</a></li><li><a href="https://github.com/nsqio/nsq">NSQ 官方 GitHub</a></li><li><a href="https://nsq.io/overview/quick_start.html">NSQ 官方快速开始</a></li><li><a href="https://nsq.io/deployment/installing.html">NSQ 安装</a></li></ul><h2 id="Part-1-服务"><a href="#Part-1-服务" class="headerlink" title="Part 1 服务"></a>Part 1 服务</h2><h3 id="nsqlookupd"><a href="#nsqlookupd" class="headerlink" title="nsqlookupd"></a>nsqlookupd</h3><p>服务发现和协调的守护进程，充当 NSQ 集群中的服务发现机制，允许生产者和消费者发现可用的 NSQ 实例</p><h3 id="nsqd"><a href="#nsqd" class="headerlink" title="nsqd"></a>nsqd</h3><p>NSQ 中的守护进程，负责接收、缓冲、投递和处理消息，是核心组件</p><h3 id="nsqadmin"><a href="#nsqadmin" class="headerlink" title="nsqadmin"></a>nsqadmin</h3><p>监控和管理 NSQ 集群的 web 界面</p><h2 id="Part-2-认证"><a href="#Part-2-认证" class="headerlink" title="Part 2 认证"></a>Part 2 认证</h2><h2 id="Part-3-生产者"><a href="#Part-3-生产者" class="headerlink" title="Part 3 生产者"></a>Part 3 生产者</h2><p>生产者客户端：与 NSQD 节点通信，将消息发布到 NSQ 中的 <code>topic</code></p><p>使用 <code>out.config</code> 配置。</p><h2 id="Part-4-消费者"><a href="#Part-4-消费者" class="headerlink" title="Part 4 消费者"></a>Part 4 消费者</h2><p>消费者客户端：订阅 <code>topic</code>  并指定一个 <code>channel</code></p><p>使用 <code>in.config</code> 配置</p><h2 id="Part-5-消息传递流"><a href="#Part-5-消息传递流" class="headerlink" title="Part 5 消息传递流"></a>Part 5 消息传递流</h2><h3 id="生产者发布消息到-topic："><a href="#生产者发布消息到-topic：" class="headerlink" title="生产者发布消息到 topic："></a>生产者发布消息到 <code>topic</code>：</h3><ul><li>生产者将消息发布到特定的 <code>topic</code>。</li><li>例如，一个生产者发布订单消息到 <code>order_topic</code>。</li></ul><h3 id="消费者订阅-topic-和-channel："><a href="#消费者订阅-topic-和-channel：" class="headerlink" title="消费者订阅 topic 和 channel："></a>消费者订阅 <code>topic</code> 和 <code>channel</code>：</h3><ul><li>消费者订阅一个 <code>topic</code>，并指定一个 <code>channel</code>。</li><li>例如，一个消费者订阅 <code>order_topic</code> 的 <code>order_processing_channel</code>。</li></ul><h3 id="消息分发："><a href="#消息分发：" class="headerlink" title="消息分发："></a>消息分发：</h3><ul><li>所有订阅了相同 <code>topic</code> 但不同 <code>channel</code> 的消费者都会各自接收到该 <code>topic</code> 的完整消息副本。</li><li>不同 <code>channel</code> 的消息相互独立，不会互相干扰。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NSQ笔记&quot;&gt;&lt;a href=&quot;#NSQ笔记&quot; class=&quot;headerlink&quot; title=&quot;NSQ笔记&quot;&gt;&lt;/a&gt;NSQ笔记&lt;/h1&gt;&lt;h2 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
    <category term="Go" scheme="https://saltyfishyjk.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>SQL笔记</title>
    <link href="https://saltyfishyjk.github.io/2024/02/24/SQL%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2024/02/24/SQL%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-24T13:37:27.000Z</published>
    <updated>2024-02-24T13:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL笔记"><a href="#SQL笔记" class="headerlink" title="SQL笔记"></a>SQL笔记</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>SQL 语言用于数据库管理系统。后文中没有特殊说明，默认为 MySQL。</p><h2 id="Part-1-SELECT"><a href="#Part-1-SELECT" class="headerlink" title="Part 1 SELECT"></a>Part 1 SELECT</h2><p>SELECT 用于从数据库中选取数据。</p><h3 id="选择特定列"><a href="#选择特定列" class="headerlink" title="选择特定列"></a>选择特定列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2 FROM table_name;</span><br></pre></td></tr></table></figure><h2 id="Part-2-WHERE"><a href="#Part-2-WHERE" class="headerlink" title="Part 2 WHERE"></a>Part 2 WHERE</h2><p>WHERE 用于添加条件和过滤。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL笔记&quot;&gt;&lt;a href=&quot;#SQL笔记&quot; class=&quot;headerlink&quot; title=&quot;SQL笔记&quot;&gt;&lt;/a&gt;SQL笔记&lt;/h1&gt;&lt;h2 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Windows Server笔记</title>
    <link href="https://saltyfishyjk.github.io/2024/01/27/Windows-Server%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2024/01/27/Windows-Server%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-27T08:10:13.000Z</published>
    <updated>2024-01-27T14:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-Server笔记"><a href="#Windows-Server笔记" class="headerlink" title="Windows Server笔记"></a>Windows Server笔记</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>Windows Server 是微软的服务器操作系统，尽管大多数场景都使用 Linux 服务器，但是在计算机网络实验等特殊场景仍需要 windows server。</p><p>本笔记主要基于 windows server 2019 操作系统，下述没有特殊说明时均为此背景。</p><h2 id="Part-1-连接"><a href="#Part-1-连接" class="headerlink" title="Part 1 连接"></a>Part 1 连接</h2><h3 id="mstsc-远程桌面"><a href="#mstsc-远程桌面" class="headerlink" title="mstsc 远程桌面"></a>mstsc 远程桌面</h3><p>mstsc 是 Windows 自带的远程桌面软件，win + R 输入 mstsc 即可打开。</p><h3 id="超级管理员"><a href="#超级管理员" class="headerlink" title="超级管理员"></a>超级管理员</h3><p>默认用户名是 administrator</p><h2 id="Part-2-创建与管理用户"><a href="#Part-2-创建与管理用户" class="headerlink" title="Part 2 创建与管理用户"></a>Part 2 创建与管理用户</h2><blockquote><p>以下操作在 administrator 下执行</p></blockquote><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><ul><li>打开“服务器管理器”（Server Manager）。</li><li>导航到“工具”（Tools） &gt; “计算机管理”（Computer Management）。</li><li>在左侧导航栏中，展开“系统工具”（System Tools），然后点击“本地用户和组”（Local Users and Groups）。</li><li>右键点击“用户”（Users）文件夹，选择“新建用户”（New User）。</li><li>按照向导填写用户信息。</li></ul><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><p>默认的密码复杂性要求：</p><ol><li><p>不能包含用户的帐户名，不能包含用户姓名中超过两个连续字符的部分</p></li><li><p>至少有六个字符长</p></li><li><p>包含以下四类字符中的三类字符:</p><ol><li>英文大写字母(A 到 Z)    </li><li>英文小写字母(a 到 z)</li><li>10 个基本数字(0 到 9)</li><li>非字母字符(例如 !、$、#、%)</li></ol></li></ol><h3 id="创建用户组"><a href="#创建用户组" class="headerlink" title="创建用户组"></a>创建用户组</h3><ol><li>打开“服务器管理器”。</li><li>导航到“本地服务器” &gt; “管理工具” &gt; “计算机管理”。</li><li>在左侧导航栏中，展开“系统工具” &gt; “本地用户和组” &gt; “组”。</li><li>右键点击要修改的用户组，选择“属性”。</li><li>在“成员”选项卡中，点击“添加”并输入要添加的组名称，点击“检查名称”确保组名正确。</li><li>确认选择后，点击“确定”来将组添加到用户组中。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-Server笔记&quot;&gt;&lt;a href=&quot;#Windows-Server笔记&quot; class=&quot;headerlink&quot; title=&quot;Windows Server笔记&quot;&gt;&lt;/a&gt;Windows Server笔记&lt;/h1&gt;&lt;h2 id=&quot;Part-0-前言</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
    <category term="Server" scheme="https://saltyfishyjk.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>Spark笔记</title>
    <link href="https://saltyfishyjk.github.io/2023/12/24/Spark%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/12/24/Spark%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-24T08:16:48.000Z</published>
    <updated>2023-12-24T12:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark-笔记"><a href="#Spark-笔记" class="headerlink" title="Spark 笔记"></a>Spark 笔记</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>Apache Spark 是一个开源的集群计算框架，可以执行大规模数据处理任务，经常和 Scala，Zeppelin 一起配合使用。</p><p>这篇笔记主要记录 Scala + Spark + Zeppelin 的使用。</p><h2 id="Part-1-Scala"><a href="#Part-1-Scala" class="headerlink" title="Part 1 Scala"></a>Part 1 Scala</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myList = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="Part-2-Spark"><a href="#Part-2-Spark" class="headerlink" title="Part 2 Spark"></a>Part 2 Spark</h2><h3 id="SparkSession"><a href="#SparkSession" class="headerlink" title="SparkSession"></a>SparkSession</h3><p>管理 Spark 应用程序的上下文，类似 Java 中的 JVM。</p><p>在 Zeppelin 中，不需要显示创建。</p><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame 是 Spark SQL 中的主要数据抽象，以列的形式组织分布式数据集，类似关系数据库的 table。</p><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><blockquote><p>暂时未使用到</p></blockquote><h2 id="Part-3-Zeppelin"><a href="#Part-3-Zeppelin" class="headerlink" title="Part 3 Zeppelin"></a>Part 3 Zeppelin</h2><h3 id="魔术命令"><a href="#魔术命令" class="headerlink" title="%  魔术命令"></a><code>%</code>  魔术命令</h3><p>用于执行特定的操作，一般放在代码块开头。</p><h4 id="example-spark"><a href="#example-spark" class="headerlink" title="%example_spark"></a><code>%example_spark</code></h4><p>类似 Jupyter 中的魔术命令，用以指定代码块的 Spark 解释器。</p><h4 id="example-spark-pyspark"><a href="#example-spark-pyspark" class="headerlink" title="%example_spark.pyspark"></a><code>%example_spark.pyspark</code></h4><p>指定代码块的 PySpark 解释器，以执行 Python 代码。</p><h2 id="Part-4-Parquet"><a href="#Part-4-Parquet" class="headerlink" title="Part 4 Parquet"></a>Part 4 Parquet</h2><p>Parquet 是一种列式数据存储格式，用于高效存储和处理大规模数据集。</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><blockquote><p>假设文件目录为 <code>/home/example</code></p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 Parquet 文件</span></span><br><span class="line"><span class="keyword">val</span> df = spark.read.parquet(<span class="string">&quot;/home/example&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示数据集内容</span></span><br><span class="line">df.show()</span><br></pre></td></tr></table></figure><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spark-笔记&quot;&gt;&lt;a href=&quot;#Spark-笔记&quot; class=&quot;headerlink&quot; title=&quot;Spark 笔记&quot;&gt;&lt;/a&gt;Spark 笔记&lt;/h1&gt;&lt;h2 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
    <category term="Scala" scheme="https://saltyfishyjk.github.io/tags/Scala/"/>
    
    <category term="Zeppelin" scheme="https://saltyfishyjk.github.io/tags/Zeppelin/"/>
    
  </entry>
  
  <entry>
    <title>Go笔记</title>
    <link href="https://saltyfishyjk.github.io/2023/12/18/Go%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/12/18/Go%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-18T02:23:17.000Z</published>
    <updated>2024-03-06T13:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go笔记"><a href="#Go笔记" class="headerlink" title="Go笔记"></a>Go笔记</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>Go，也称 Golang，是 Google 开发的编程语言，其轻量级协程使得在处理高并发需求时表现出色。</p><h2 id="Part-1-安装"><a href="#Part-1-安装" class="headerlink" title="Part 1 安装"></a>Part 1 安装</h2><h3 id="Linux-Ubuntu"><a href="#Linux-Ubuntu" class="headerlink" title="Linux - Ubuntu"></a>Linux - Ubuntu</h3><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/629240139">如何在 Debian / Ubuntu 上安装 Go 开发环境</a></p><blockquote><p>推荐使用其中的<strong>官方二进制包</strong>方式安装，因为 apt 方式安装的版本过旧</p></blockquote><h4 id="设置国内代理"><a href="#设置国内代理" class="headerlink" title="设置国内代理"></a>设置国内代理</h4><p>参考博客：<a href="https://www.jianshu.com/p/9bffc3f45c7d">go get 报错:dial tcp 142.251.43.17:443: i/o timeout</a></p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/255030682">Go 语言在 Windows 上的安装及配置</a></p><h2 id="Part-2-语言结构"><a href="#Part-2-语言结构" class="headerlink" title="Part 2 语言结构"></a>Part 2 语言结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个 go 源文件都需要在开头声明所属包 <code>package main</code></li><li>在 main 包中声明的 <code>main</code> 函数被视为程序入口<ul><li>如果代码中有 <code>init</code> 函数，那么会在程序执行之初自动执行</li><li>如果引入的包有 <code>init</code> 函数，会按照导入顺序执行各个包的 <code>init</code> 函数</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go笔记&quot;&gt;&lt;a href=&quot;#Go笔记&quot; class=&quot;headerlink&quot; title=&quot;Go笔记&quot;&gt;&lt;/a&gt;Go笔记&lt;/h1&gt;&lt;h2 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
    <category term="Go" scheme="https://saltyfishyjk.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>dnspython 笔记</title>
    <link href="https://saltyfishyjk.github.io/2023/12/02/dnspython-%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/12/02/dnspython-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-02T12:06:34.000Z</published>
    <updated>2023-12-18T02:22:42.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>PyTorch Notes</title>
    <link href="https://saltyfishyjk.github.io/2023/08/04/PyTorch-Notes/"/>
    <id>https://saltyfishyjk.github.io/2023/08/04/PyTorch-Notes/</id>
    <published>2023-08-04T12:46:32.000Z</published>
    <updated>2023-08-04T13:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PyTorch-Notes"><a href="#PyTorch-Notes" class="headerlink" title="PyTorch Notes"></a>PyTorch Notes</h1><h2 id="Part-0-简介"><a href="#Part-0-简介" class="headerlink" title="Part 0 简介"></a>Part 0 简介</h2><p>PyTorch 是目前最流行的深度学习框架之一。</p><p>参考资料：</p><ul><li><a href="https://pytorch.org/">PyTorch官方网站</a></li><li><a href="https://blog.csdn.net/weixin_44630522/article/details/122377337">PyTorch+Windows 配置</a>：该贴在我的机器上可行</li><li><a href="https://pytorch-cn.readthedocs.io/zh/latest/">PyTorch中文文档</a></li></ul><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><h3 id="with-torch-no-grad"><a href="#with-torch-no-grad" class="headerlink" title="with torch.no_grad()"></a><code>with torch.no_grad()</code></h3><p>PyTorch 中的一个上下文管理器（context manager），提供一个临时的运行环境，在该环境中，所有 PyTorch 的操作不会被自动求导（AutoGrad），即，不会对计算图进行记录，从而节省内存并提高运行速度。</p><p>具体地，在深度学习中，训练阶段往往需要计算模型的梯度并使用梯度更新模型的参数，以进行反向传播和优化；在测试阶段，通常只需要进行前向传播以获取模型的输出，而不需要再计算梯度，因此，此时使用 <code>with torch.no_grad()</code> 可以节约资源，避免不必要的计算。</p><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y)  <span class="comment"># X和y的小批量损失</span></span><br><span class="line">        <span class="comment"># 因为l形状是(batch_size,1)，而不是一个标量。l中的所有元素被加到一起，</span></span><br><span class="line">        <span class="comment"># 并以此计算关于[w,b]的梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w, b], lr, batch_size)  <span class="comment"># 使用参数的梯度更新参数</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>该代码片段来自<a href="https://zh-v2.d2l.ai/chapter_linear-networks/linear-regression-scratch.html">d2l</a>，其中，<code>with torch.no_grad()</code> 环境下进行 <code>loss</code> 的计算，用以直观表现每一个 epoch 后的优化效果（即应当观察到 loss 越来越小），此时并非要进行训练，因此只进行前向传播和计算（预测）即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PyTorch-Notes&quot;&gt;&lt;a href=&quot;#PyTorch-Notes&quot; class=&quot;headerlink&quot; title=&quot;PyTorch Notes&quot;&gt;&lt;/a&gt;PyTorch Notes&lt;/h1&gt;&lt;h2 id=&quot;Part-0-简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
    <category term="PyTorch" scheme="https://saltyfishyjk.github.io/tags/PyTorch/"/>
    
    <category term="Deep Learning" scheme="https://saltyfishyjk.github.io/tags/Deep-Learning/"/>
    
    <category term="Machine Learning" scheme="https://saltyfishyjk.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>「BUAA SE Individual Work3」提问回顾与个人总结</title>
    <link href="https://saltyfishyjk.github.io/2023/06/16/%E3%80%8CBUAA-SE-Individual-Work3%E3%80%8D%E6%8F%90%E9%97%AE%E5%9B%9E%E9%A1%BE%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://saltyfishyjk.github.io/2023/06/16/%E3%80%8CBUAA-SE-Individual-Work3%E3%80%8D%E6%8F%90%E9%97%AE%E5%9B%9E%E9%A1%BE%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</id>
    <published>2023-06-16T11:22:05.000Z</published>
    <updated>2023-06-17T01:20:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「BUAA-SE-Individual-Work3」提问回顾与个人总结"><a href="#「BUAA-SE-Individual-Work3」提问回顾与个人总结" class="headerlink" title="「BUAA SE Individual Work3」提问回顾与个人总结"></a>「BUAA SE Individual Work3」提问回顾与个人总结</h1><h2 id="Part-1-前言"><a href="#Part-1-前言" class="headerlink" title="Part 1 前言"></a>Part 1 前言</h2><div class="table-container"><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">内容</th></tr></thead><tbody><tr><td style="text-align:left">这个作业属于哪个课程</td><td style="text-align:left"><a href="https://bbs.csdn.net/forums/buaa-ase2023">2023年北航敏捷软件工程</a></td></tr><tr><td style="text-align:left">这个作业的要求在哪里</td><td style="text-align:left"><a href="https://bbs.csdn.net/topics/615769461">个人作业-提问回顾与个人总结</a></td></tr><tr><td style="text-align:left">我们在这个课程的目标是</td><td style="text-align:left">熟悉结对编程的<strong>方法论</strong>，并通过实际开发实现最长英语单词链这一产品进行<strong>实践</strong>。</td></tr><tr><td style="text-align:left">这个作业在哪个<strong>具体方面</strong>帮助我实现目标</td><td style="text-align:left">通过在最长英语单词链这一应用中实践结对编程的方法论。</td></tr></tbody></table></div><ul><li>教学班级  ： 周四班                               </li><li>提问博客地址：<a href="https://bbs.csdn.net/topics/613630584">「BUAA SE Individual Work1」阅读和提问</a></li></ul><h2 id="Part-2-对自己曾经提出的问题进行解答"><a href="#Part-2-对自己曾经提出的问题进行解答" class="headerlink" title="Part 2 对自己曾经提出的问题进行解答"></a>Part 2 对自己曾经提出的问题进行解答</h2><h3 id="问题1：根据软件的不同、团队规模的不同以及团队成员的不同，最合适的团队模式肯定有所区别。那么在一个团队刚成立的时候，该如何快速先行选择一个团队模式开展工作，且这个模式虽然未必最佳但是至少是次最佳？"><a href="#问题1：根据软件的不同、团队规模的不同以及团队成员的不同，最合适的团队模式肯定有所区别。那么在一个团队刚成立的时候，该如何快速先行选择一个团队模式开展工作，且这个模式虽然未必最佳但是至少是次最佳？" class="headerlink" title="问题1：根据软件的不同、团队规模的不同以及团队成员的不同，最合适的团队模式肯定有所区别。那么在一个团队刚成立的时候，该如何快速先行选择一个团队模式开展工作，且这个模式虽然未必最佳但是至少是次最佳？"></a>问题1：根据软件的不同、团队规模的不同以及团队成员的不同，最合适的团队模式肯定有所区别。那么在一个团队刚成立的时候，该如何快速先行选择一个团队模式开展工作，且这个模式虽然未必最佳但是至少是次最佳？</h3><p>在本学期的软工团队项目中，我通过实践和讨论找到了这个问题的一个解决方案。</p><p>具体地，在项目开始前，我和一些选过本门课程的学长学姐沟通讨论，了解他们的团队合作方案，其中对我帮助最大的是去年的无际软工队，是我们团队合作学习的榜样。</p><p>另外，我们还进行了团队内的讨论，了解彼此的擅长和不擅长的工作，尽可能发挥各自的长处，这也让我们的团队合作模式具有特色。具体地，我们由1PM+4前端+2后端组成，我作为PM主要负责进度协调、文档管理、运行维护、博客撰写等工作，前端和后端以常见的模式分工。这带来了巨大的好处，也就是我们基本保证了每位成员都在做其擅长且较愿意做的工作。</p><p>当然，这个过程也不是一成不变的。在项目推进中，我们也根据实际情况逐步调整了合作模式与具体分工，更好地适应了变化。</p><h3 id="问题2：如何合适地分而治之？"><a href="#问题2：如何合适地分而治之？" class="headerlink" title="问题2：如何合适地分而治之？"></a>问题2：如何合适地分而治之？</h3><p>在团队项目中，我通过实践找到了这个问题的一个解决方案。</p><p>我作为PM，确实没有对前后端所有技术都精通，但是得益于过去的项目经验，我对前后端的技术和工作都有一定把握。在这个基础上，我们主要采用团队敲定项目内容和实现方案后，由开发人员具体来进行时间安排和进度规划，PM主要进行协调以及判断是否可行，是否留有了充分的时间缓冲等。</p><h3 id="问题3：如何推行高效工作工具如源代码管理工具Git等？"><a href="#问题3：如何推行高效工作工具如源代码管理工具Git等？" class="headerlink" title="问题3：如何推行高效工作工具如源代码管理工具Git等？"></a>问题3：如何推行高效工作工具如源代码管理工具Git等？</h3><p>在本学期，我通过实践和讨论解决了这个问题。</p><p>首先，在项目开始前，我和 @TA熊 深入讨论了推广团队合作工具的问题：<a href="https://bbs.csdn.net/topics/613944863">讨论：关于团队的技术栈和项目管理工具选择</a>，这一富有成效的讨论得到了一个初步解决方案：结合工具的特点、人的特点、过去工作/项目的经验，尝试设想【真实的场景和需求】，而非被创造的需求。具体地，我们采用了如下方案：</p><ol><li>代码托管平台：GitHub</li><li>部署：GitHub Actions + 云服务器（可能选择腾讯云等提供商，已经有过成功案例）</li><li>即时通讯：微信+腾讯会议（进行碎片化的、快速的沟通）</li><li>【待确定】文档管理（公共知识库）：notion /飞书（工作场景包括数据统计、协作编辑、信息组织、公共作业完成、开发规范、任务分配、进度（看板）管理等）</li></ol><p>可以注意到，上述工具链中有不少“老熟人”，其中的GitHub、腾讯云、微信、腾讯会议都是大家日常生活中就常用的生产力工具，唯一的新面孔是notion，而其支持markdown语法的特性也大大平缓了大家的学习曲线。</p><p>在实践中，我们通过上述方案快速搭建起了一套行之有效、易于上手的工具链，真正做到了让团队不沉迷于工具的选择层面，而更专注于业务本身。</p><h3 id="问题4：对于渐进发布的产品，如何使用合适的工具或解决方案以实现最佳DevOps？"><a href="#问题4：对于渐进发布的产品，如何使用合适的工具或解决方案以实现最佳DevOps？" class="headerlink" title="问题4：对于渐进发布的产品，如何使用合适的工具或解决方案以实现最佳DevOps？"></a>问题4：对于渐进发布的产品，如何使用合适的工具或解决方案以实现最佳DevOps？</h3><p>我通过实践搞清楚了这件事。</p><p>在本学期软工之前，我就对DevOps、Docker、CI/CD等工具有所耳闻，但是只停留在听说过的程度，对其长什么样，如何使用，有什么效果还是整体比较模糊的。在本学期的团队项目实践过程中，我大量调研了GitHub Actions、CI/CD、Docker、DockerHub等工具，最终确定并实践了我们的解决方案，搭建了行之有效的DevOps工具链，真正做到了持续部署持续交付。同时，在本学期我还进行了一次Talk，主题就是CI/CD，向大家介绍我们的工作经验，取得了良好的反响。</p><h3 id="问题5：如何用科学的方法或者技术辅助提高领导力进而快速带领团队成长？"><a href="#问题5：如何用科学的方法或者技术辅助提高领导力进而快速带领团队成长？" class="headerlink" title="问题5：如何用科学的方法或者技术辅助提高领导力进而快速带领团队成长？"></a>问题5：如何用科学的方法或者技术辅助提高领导力进而快速带领团队成长？</h3><p>我通过实践弄清楚了这件事。</p><p>对于软工团队项目这样规模的组织，既需要有个人魅力和领导能力的PM，也需要精简高效的组织架构和规则，两条腿走路才能不偏废。</p><p>具体地，本学期中我们在初期即确定了奖励和惩罚规则，规则的数量不多，但是为大家划定了清晰的要求，大家也都在本学期中充分遵守了这些规则，一套简洁有效的组织架构就此诞生；另外，我作为PM也较有责任心和规划意识，对关键的时间节点和应有的进度有清晰的把握，我相信这也给成员们带来了安心和踏实，也让我们有信心应对可能发生的突发情况。</p><hr><p>总的来说，本学期初提的五个问题都已经得到了良好的解决，至少找到了一个不错的切实可行的解决方案，这也让我更加深刻意识到了软件工程是一门实践的科学。</p><h2 id="Part-3-在项目的需求-设计-实现-测试-发布-维护阶段（一共6-个阶段）中都学到了什么“知识点”"><a href="#Part-3-在项目的需求-设计-实现-测试-发布-维护阶段（一共6-个阶段）中都学到了什么“知识点”" class="headerlink" title="Part 3 在项目的需求/设计/实现/测试/发布/维护阶段（一共6 个阶段）中都学到了什么“知识点”"></a>Part 3 在项目的需求/设计/实现/测试/发布/维护阶段（一共6 个阶段）中都学到了什么“知识点”</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>主要的设计和架构比较清晰，但是对于用户的使用需求的把握仍有进步空间。如果可以重来的话，我们会进行更完善的用户调研，对各项工作的优先级进行更细致的划分；在用户使用方面，我们发现出现了明显的倾斜，如学生们对物理答疑的需求较大，但是物理的辅导师人数却相对较少，且回答热情不高，这是本软件之外的问题，但是也应作为现状和用户需求的一部分纳入考虑，如进行更广泛的宣传动员、实施更行之有效的奖励激励政策。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>设计部分，我学到了使用EoLink等现代工具辅助可以达到事半功倍的效果。在ER图绘制中，需要反复磋商讨论确定前后端的对接方案，但是即使如此，在实践过程中仍可能需要将进行一些调整，需要让每一个团队成员都清楚地了解设计的变更。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在实现过程中，我充分意识到了官方文档、GitHub、StackOverflows等工具的重要性，不能只依赖中文资料。具体地，在实现一个向窗口发送 <code>ctrl + C</code> 命令时，在中文互联网查了很多，但没有得到有效的解决方案，而一旦切换到英文搜索，就在StackOverflows找到了答案。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>充分的测试必不可少。在Alpha阶段的第一个内测版本中，我们进行了部分测试即上线，立刻收获了内测用户的大量问题反馈，这充分说明当时我们的测试不够充分和全面。而在Beta公测前，我们就在测试服进行了较全面充分的测试，最终上线时也顶住了压力，没有出严重的问题。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>软件的发布需要团队成员一起确认，以防止开发分支存在已知的重要问题上线到生产环境产生问题。数据库的迁移也十分重要，如表的新建与更新等，需要可向前兼容地合并到生产环境。</p><p>可靠性和鲁棒性是十分重要的，一些花哨的功能实现的不好或者没有实现影响不大，而核心功能不能出任何问题，向前兼容也是必须要实现的功能。</p><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>CI/CD是非常行之有效的运维工具链，本学期我通过GitHub Actions、Docker等工具充分实现了持续部署和持续交付，实现了复杂动作的自动化，提升了项目的可维护性。</p><h2 id="Part-4-理解与心得"><a href="#Part-4-理解与心得" class="headerlink" title="Part 4 理解与心得"></a>Part 4 理解与心得</h2><p>在个人项目中，我对代码托管平台进行了较为充分的调研，让我从用户转变到开发者的角度近距离观察了这一和我们工作生活关系紧密的工具，让我对软件有了更深刻的理解。</p><p>在结对编程和团队项目中，我都非常幸运拥有非常棒的队友，他们强大、可靠、善于沟通，我们一起完成了非常有影响力的工作，没有他们的帮助，也没有这个学期产出的优秀项目；在这之中，我也大大锻炼了自己的合作能力，提高了沟通能力和技巧，为以后的团队合作奠定了基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「BUAA-SE-Individual-Work3」提问回顾与个人总结&quot;&gt;&lt;a href=&quot;#「BUAA-SE-Individual-Work3」提问回顾与个人总结&quot; class=&quot;headerlink&quot; title=&quot;「BUAA SE Individual Wo</summary>
      
    
    
    
    
    <category term="BUAA-SE" scheme="https://saltyfishyjk.github.io/tags/BUAA-SE/"/>
    
  </entry>
  
  <entry>
    <title>「CS231n Course 4」卷积神经网络</title>
    <link href="https://saltyfishyjk.github.io/2023/06/12/%E3%80%8CCS231n-Course-4%E3%80%8D%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://saltyfishyjk.github.io/2023/06/12/%E3%80%8CCS231n-Course-4%E3%80%8D%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2023-06-12T02:35:23.000Z</published>
    <updated>2023-08-04T12:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「CS231n-Course-4」卷积神经网络"><a href="#「CS231n-Course-4」卷积神经网络" class="headerlink" title="「CS231n Course 4」卷积神经网络"></a>「CS231n Course 4」卷积神经网络</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>参考资料：</p><ul><li><a href="https://www.bilibili.com/video/BV1Gb4y1X7Q5/?p=16&amp;vd_source=b0a8793490273b09808dbd6f72d3465c">b站 CS231n 5.1 卷积和池化</a></li><li><a href="https://zhuanlan.zhihu.com/p/22038289?refer=intelligentunit">知乎 卷积神经网络笔记</a></li><li><a href="https://cs231n.github.io/convolutional-networks/">CS231n Convolutional Neural Networks Note(official)</a></li><li><a href="https://cs.stanford.edu/people/karpathy/convnetjs/demo/cifar10.html">浏览器中运行的CNN demo</a></li></ul><h2 id="Part-1-卷积神经网络概述"><a href="#Part-1-卷积神经网络概述" class="headerlink" title="Part 1 卷积神经网络概述"></a>Part 1 卷积神经网络概述</h2><p>卷积神经网络（Convolutional Neural Network, CNN）和上一章中讲述的神经网络非常相似：由神经元组成，神经元中有具有学习能力的权重和偏差。每个神经元得到一些输入，进行内积运算（dot product）再进行激活函数运算。整个网络依旧是一个可导的评分函数：该函数的输入是原始的图像像素，输出是不同类别的评分。再最后一层（往往是全连接层），网络依旧有一个损失函数（如SVM或Softmax），并且在神经网络中实现的各种技巧和要点依旧适用于卷积神经网络。</p><h3 id="CNN和NN相比的变化"><a href="#CNN和NN相比的变化" class="headerlink" title="CNN和NN相比的变化"></a>CNN和NN相比的变化</h3><p>CNN的结构基于一个假设：输入数据是图像。基于该假设，CNN向结构中添加了一些特有的性质，使得前向传播函数（forward function）更加高效，并且可以大幅降低网络中参数的数量。</p><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><h4 id="回顾：常规神经网络（Regular-Neural-Network但不是RNN）"><a href="#回顾：常规神经网络（Regular-Neural-Network但不是RNN）" class="headerlink" title="回顾：常规神经网络（Regular Neural Network但不是RNN）"></a>回顾：常规神经网络（Regular Neural Network<del>但不是RNN</del>）</h4><p>在上一章中，神经网络的输入是一个向量，然后在一系列隐层中对其做变换。其中，每个隐层是由若干神经元组成的，每个神经元都与前一层中的所有神经元连接（全连接）。但是在一个隐层中，神经元相互独立而不进行任何连接。最后的全连接层被称为”输出层“，在分类问题中，输出值被看作是不同类别的评分值。</p><h4 id="常规神经网络对于大尺寸图像的效果不尽如人意"><a href="#常规神经网络对于大尺寸图像的效果不尽如人意" class="headerlink" title="常规神经网络对于大尺寸图像的效果不尽如人意"></a>常规神经网络对于大尺寸图像的效果不尽如人意</h4><p>观察常规神经网络的工作，其将图像（如CIFAR10中的 $32 \times 32 \times 3$ ，表示宽和高为 $32$ 个像素，$3$ 个颜色通道）展开为一个列向量，那么每一个全连接神经元就包含 $32 \times 32 \times 3=3072$ 个权重，这个数量级目前看来还好。但是如果图像尺寸更大，如 $200 \times 200 \times 3$ ，那么神经元就会包含 $200 \times 200 \times 3=120,000$ 个权重值，而网络中不止包含一个神经元，所以网络的参数量会快速膨胀。由此也可以发现，全连接结构不适合更大尺寸的图像，这种全连接的方式效率低下，参数量过大也很快会导致网络过拟合。</p><h4 id="神经元的三维排列"><a href="#神经元的三维排列" class="headerlink" title="神经元的三维排列"></a>神经元的三维排列</h4><p>CNN针对输入全部是图像的情况，将结构调整地更加合理，获得了不小的优势。</p><p>与常规神经网络不同，CNN中的各层的神经元是3维排列的：<strong>宽度</strong>、<strong>高度</strong>和<strong>深度</strong>（此处的深度是指激活数据体（activation volume）的三个维度，不是神经网络的深度，整个网络的深度指的是网络的层数）。</p><p>举例而言，CIFAR-10中的图像是CNN的输入，该数据体（volume）的维度是 $32 \times 32 \times 3$ （宽度7高度和深度）。可以看到，层中的神经元只与前一层中的一小块区域连接，而非全连接，因为在CNN的最后部分会将全尺寸的图像压缩为包含分类评分的一个向量，向量是在深度方向排列的。</p><p>e.g.</p><table><tr>    <td>        <img src='NN v.s. CNN1.jpeg' align='center' width=8000>    </td>    <td>        <img src='NN v.s. CNN2.jpeg' align='center' width=8000>    </td>    </tr>    </table><p>左边是一个 $3$ 层的神经网络；右边是一个CNN，其神经元以 $3$ 个维度（宽度、高度、深度）进行排列。CNN的每一层将 $3$ 维的输入数据（3D input volume）变化为神经元 $3$ 维的激活数据（3D output volume of neuron activations）并输出。在本例中，红色的输入层就是图像，因此其宽度和高度就是图像的尺寸（dimensions of the image），而深度是 $3$ （RGB通道）。</p><blockquote><p>CNN是由层组成的，每一层都有一个简单的API：用一些含参或者不含参的可导的函数，将输入的3D数据变换为3D的输出数据</p></blockquote><h2 id="Part-2-构建CNN的层"><a href="#Part-2-构建CNN的层" class="headerlink" title="Part 2 构建CNN的层"></a>Part 2 构建CNN的层</h2><p>CNN是由各种层按照顺序排列组成的，网络中的每个层使用一个可微分的函数将激活数据从一个层传递到另一个层。</p><p>CNN中主要有三种层：卷积层（Convolutional Layer）、池化层（Pooling Layer）和全连接层（Fully-Connected Layer）（全连接层和常规NN中的一样）。</p><p>通过这些层的叠加，就可以构建一个完整的CNN。</p><p><strong>网络结构示例</strong>：[输入层-卷积层-ReLU层-全连接层]（[INPUT-CONV-ReLU-POOL-FC]）</p><ul><li><p>输入 $[32 \times 32 \times 3]$ 存有图像的原始像素值，本例中图像宽度和高度为 $32$ ，有 $3$ 个颜色通道</p></li><li><p>卷积层中，神经元和输入层的一个局部区域项链，每个神经元都计算自己与输入层相连的小区域与自己权重的内积。卷积层会计算所有神经元的输出。如果使用12个卷积核（filter，也叫滤波器），得到的输出数据体的维度是 $[32 \times 32 \times 12]$ 。</p><blockquote><p>笔者注：这里应该是使用了零填充（zero pad），因此卷积核没有将输入的维度压缩</p></blockquote></li><li><p>ReLU层会逐个元素进行激活函数操作，如使用 $max(0,x)$ 作为激活函数。该层不改变数据尺寸，仍是 $[32 \times 32 \times 12]$。</p></li><li><p>池化层在空间维度（宽度和高度）进行降采样（downsampling），降低了数据尺寸到 $[16 \times 16 \times 12]$。</p></li><li><p>全连接层计算分类评分，数据尺寸变为 $[1 \times 1 \times 10]$，这 $10$ 个数字对应 CIFAR-10 中 $10$ 个类别的分类评分值。和常规神经网络中的一样，其中每个神经元与前一层中所有神经元相连接。</p></li></ul><p>由此看来，CNN一层层地将图像从原始像素值变换成最终的分类评分制。其中有的层含有参数，有的没有，具体地：</p><ul><li>卷积层和全连接层对输入执行变换操作时，不仅会用到激活函数，还会用到很多参数（神经元的突触权值和偏差）。</li><li>ReLU层和池化层则是进行一个固定不变的函数操作，没有参数或者权值更新。</li></ul><p>卷积层和全连接层中的参数会随着梯度下降而被训练，这样CNN计算出的分类评分就能和训练集中的每个图像的标签相吻合。</p><p><strong>小结</strong></p><ul><li>上述的简单CNN中，就是通过一系列的层将输入数据变换为输出数据（如分类评分）</li><li>CNN结构中有几种不同的类型（目前流行的有卷积层、全连接层、ReLU层和池化层）</li><li>每个层的输入是 3D 数据，然后使用一个可导的函数将其变换为 3D 的输出数据</li><li>有的层有参数，有的没有（卷积层和全连接层有参数，ReLU层和池化层没有）</li><li>有的层有额外的超参数，有的没有（卷积层、全连接层和池化层有，ReLU层没有）</li></ul><p>一个CNN激活输出demo：</p><p><img src="CNN_demo.jpeg" alt="CNN_demo"></p><p>在这个例子中，左边的输入层存有原始图像像素，右边的输出层存有类别分类评分。在处理流程中，每个激活数据体是铺成一列来展示的。</p><hr><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积层是构建CNN的核心层，它产生了网络中大部分的计算量。</p><h4 id="概述和直观介绍"><a href="#概述和直观介绍" class="headerlink" title="概述和直观介绍"></a>概述和直观介绍</h4><p>卷积层的参数是由一些<strong>可学习的（learnable）</strong>卷积核的<strong>集合</strong>构成的。每个卷积核（filter）在空间上（宽度和高度，width and height）都比较小，但是深度和输入数据一致。</p><p>举例来说，CNN第一层的一个典型卷积核的尺寸可以是 $5 \times 5 \times 3$ （宽度和高度是 $5$ 像素，深度是 $3$ 是因为图像的深度是 $3$，即颜色通道）。在前向传播（forward pass）的时候，让每个卷积核在输入数据的宽度和高度上滑动（更精确地说是<strong>卷积（convolve）</strong>），然后计算卷积核和输入数据任一处的内积。当卷积核沿着输入数据的宽度和高度滑过后，会生成一个 <strong>2 维</strong> 的激活图（activation map），激活图给出了每个空间位置处的卷积核的反应（response）。直观地说，网络会让卷积核学习到当其看到某些类型的视觉特征时就激活，具体的视觉特征可能是某些方位上的边界，或者在第一层上某些颜色的半点，甚至可以是网络更高层上的蜂巢状或者车轮状图案。</p><p>在每个卷积层上，会有一整个集合的卷积核（如 $12$ 个），每个都会生成一个不同的二维激活图（$2$ D activation map）。将这些激活映射在深度方向上层叠起来就生成了输出数据。</p><h4 id="以大脑比喻的视角"><a href="#以大脑比喻的视角" class="headerlink" title="以大脑比喻的视角"></a>以大脑比喻的视角</h4><p>输出的 3D 数据中的每个数据项可以被看作是神经元的一个输出，而这个神经元只观察输入数据的一小部分，并且和空间上左右两边的所有神经元共享参数（因为这些数字都是使用同一个卷积核得到的结果）。现在讨论神经元的连接、他们在空间中的排列以及他们参数共享的模式。</p><h4 id="局部连接"><a href="#局部连接" class="headerlink" title="局部连接"></a>局部连接</h4><p>处理图像这类高纬度输入时，让每个神经元都与前一层中的所有神经元进行全连接是不现实的。相反，我们让每个神经元只与输入数据的一个局部区域连接，该连接（connectivity）的空间大小叫做神经元的<strong>感受野（receptive field）</strong>，它的尺寸是一个超参数（其实就是卷积核的空间尺寸）。在深度方向上，这个连接的大小总是和输入量的深度相等。</p><p>再次强调，我们对待空间维度（宽和高）与深度维度是不同的：连接在空间（宽和高）上是局部的，但是在深度上总是和输入数据的深度一致。</p><p><strong>e.g.1</strong></p><p>假设输入数据的尺寸是 $[32 \times 32 \times 3]$ （如CIFAR-10的RGB图像）；如果感受野（或卷积核尺寸）是 $5 \times 5$ ，那么卷积层中的每个每个神经元会有输入数据体中 $[5 \times 5 \times 3]$ 区域的权重，共 $5 \times 5 \times 3=75$ 个权重（还要再加一个偏差参数 bias parameter）。这个连接在深度维度上的大小必须为 $3$ ，这是和输入数据体的深度保持一致。</p><p><strong>e.g.2</strong></p><p>假设输入数据体的尺寸是 $[16 \times 16 \times 20]$，感受野尺寸是 $3 \times 3$，那么卷积层中每个神经元和输入数据体有 $3\times 3\times 20=180$ 个连接。</p><blockquote><p>在空间上连接是局部的，但是在深度上是和输入数据体一致的</p></blockquote><hr><table><tr>    <td>        <img src='depthcol.jpeg' align='center' width=8000>    </td>    <td>        <img src='neuron_model.jpeg' align='center' width=8000>    </td>    </tr>    </table><ul><li>左边：红色的是输入数据体（如CIFAR-10中的图像），蓝色的部分是第一个卷积层中的神经元。<strong>卷积层中的每个神经元都只与输入数据体的一个局部在空间上相连，但是与输入数据体的所有深度维度全部相连（在这个例子中，是RGB三个颜色通道）</strong>。在深度方向上，有多个神经元（本例中是 $5$ 个），他们都接收输入数据的同一块区域（感受野相同）。</li><li>右边：神经网络章节中介绍的神经元保持不变，仍计算权重和输入的内积，然后进行激活函数运算。区别在于，卷积层的连接被限制在一个局部空间。</li></ul><hr><h4 id="空间排列"><a href="#空间排列" class="headerlink" title="空间排列"></a>空间排列</h4><p>接下来讨论输出数据体中神经元的数量以及它们的排列方式。有 $3$ 个超参数控制输出数据体的尺寸：深度（depth）、步长（stride）和零填充（zero-padding）</p><ol><li><p>深度（depth）。输出数据体的深度是一个超参数，其和使用的<strong>卷积核数量</strong>一致，而每个卷积核在输入数据中寻找不同的东西。举例来说，如果第一个卷积层的输入是原始图像，那么在深度维度上的不同神经元将可能被不同方向的边界（various oriented edges），或者是颜色斑点（blobs of color）激活。</p></li><li><p>步长（stride）。其次，在滑动卷积核时，必须指定步长。当步长为 $1$ 时，卷积核每次移动 $1$ 个像素。当步长为 $2$ （或不常用的 $3$，这在实际中很少使用），卷积核每次滑动时移动 $2$ 个像素。这个操作会让输出数据体在空间上变小。</p><blockquote><p>选择步长时，应当保证可以卷积核可以正好移动覆盖完。</p></blockquote></li><li><p>零填充（zero-padding）。有时候，我们不希望出现数据体尺寸变小的情况，因此可以使用零填充。零填充就是指在输入数据体的边缘用 $0$ 填充，其尺寸是一个超参数。零填充可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，这样输入和输出的宽高相等）</p></li></ol><p>输出数据体在空间上的尺寸可以通过数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「CS231n-Course-4」卷积神经网络&quot;&gt;&lt;a href=&quot;#「CS231n-Course-4」卷积神经网络&quot; class=&quot;headerlink&quot; title=&quot;「CS231n Course 4」卷积神经网络&quot;&gt;&lt;/a&gt;「CS231n Course 4」</summary>
      
    
    
    
    
    <category term="CS231n" scheme="https://saltyfishyjk.github.io/tags/CS231n/"/>
    
    <category term="Deep Learning" scheme="https://saltyfishyjk.github.io/tags/Deep-Learning/"/>
    
    <category term="Machine Learning" scheme="https://saltyfishyjk.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Marp笔记</title>
    <link href="https://saltyfishyjk.github.io/2023/05/24/Marp%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/05/24/Marp%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-24T15:55:40.000Z</published>
    <updated>2023-10-19T07:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Marp笔记"><a href="#Marp笔记" class="headerlink" title="Marp笔记"></a>Marp笔记</h1><h1 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h1><p>Marp 是一个支持使用 markdown 快速制作精简大方的 PPT 的工具，在一些场景十分有用（特别是已经有了 markdown 文档且需要制作 PPT 汇报时）。目前的使用方式主要是在 VSCode 中安装 Marp 插件，进行类似经典 markdown 编辑器的双屏浏览（左边源码，右边实时渲染）。</p><p>优点：</p><ul><li>支持 markdown 语法</li><li>不需要特别设置字体字号，不需要排版</li><li>制作快速</li></ul><p>参考资料：</p><ul><li><a href="https://marp.app">Marp官网</a></li><li><a href="https://zhuanlan.zhihu.com/p/447797515">用Markdown写PPT ，Marp的果壳主题</a></li><li><a href="https://cloud.tencent.com/developer/article/1942512">用Markdown制作幻灯片:Marp</a></li><li><a href="https://caizhiyuan.gitee.io/categories/skills/20200730-marp.html#%E5%8A%9F%E8%83%BD">marp Markdown演示编写器</a></li></ul><h2 id="Part-1-基本格式与用法"><a href="#Part-1-基本格式与用法" class="headerlink" title="Part 1 基本格式与用法"></a>Part 1 基本格式与用法</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>通过 <code>---</code>进行手动分页展示，表示另起新页</p><h3 id="front-martter-头信息"><a href="#front-martter-头信息" class="headerlink" title="front-martter 头信息"></a>front-martter 头信息</h3><p>在文件头部添加信息，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">marp: true</span><br><span class="line">theme: </span><br><span class="line">paginate: true</span><br></pre></td></tr></table></figure><p>其中 <code>marp:true</code> 表示这是 <code>marp</code> 文件，<code>paginate:true</code> 表示自动标页码</p><h2 id="Part-2-图片"><a href="#Part-2-图片" class="headerlink" title="Part 2 图片"></a>Part 2 图片</h2><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>通过 <code>![bg](backgroung.jpg)</code> 标记，其中，<code>bacckground.jpg</code> 为背景图片文件名，在本例中它应该和 markdown 文件放在一个目录下。仅在标注了该语句的页面显示背景图片。</p><p>透明度：<code>![bg opacity:.10](bg.png)</code>，opacity 表示透明度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Marp笔记&quot;&gt;&lt;a href=&quot;#Marp笔记&quot; class=&quot;headerlink&quot; title=&quot;Marp笔记&quot;&gt;&lt;/a&gt;Marp笔记&lt;/h1&gt;&lt;h1 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>「CS231n Course 3」神经网络简介</title>
    <link href="https://saltyfishyjk.github.io/2023/05/24/%E3%80%8CCS231n-Course-3%E3%80%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/"/>
    <id>https://saltyfishyjk.github.io/2023/05/24/%E3%80%8CCS231n-Course-3%E3%80%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/</id>
    <published>2023-05-24T14:04:48.000Z</published>
    <updated>2023-08-04T12:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「CS231n-Course-3」神经网络简介"><a href="#「CS231n-Course-3」神经网络简介" class="headerlink" title="「CS231n Course 3」神经网络简介"></a>「CS231n Course 3」神经网络简介</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>参考资料：</p><ul><li><a href="https://www.bilibili.com/video/BV1Gb4y1X7Q5?p=12&amp;vd_source=b0a8793490273b09808dbd6f72d3465c">b站 CS231n 4.1 反向传播</a></li><li><a href="https://www.bilibili.com/video/BV1Gb4y1X7Q5/?p=13&amp;spm_id_from=pageDriver&amp;vd_source=b0a8793490273b09808dbd6f72d3465c">b站 CS231n 4.2 神经网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/21407711?refer=intelligentunit">知乎 反向传播笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/21462488?refer=intelligentunit">神经网络笔记1（上）</a></li><li><a href="https://cs231n.github.io/optimization-2/">CS231n Backprop Note(official)</a></li><li><a href="https://zhuanlan.zhihu.com/p/21513367?refer=intelligentunit">神经网络笔记1（下）</a></li><li><a href="https://cs231n.github.io/neural-networks-1/">CS231n Neural Network Note-1(official)</a></li></ul><h2 id="Part-1-反向传播"><a href="#Part-1-反向传播" class="headerlink" title="Part 1 反向传播"></a>Part 1 反向传播</h2><p>反向传播，<strong>Back Propagation(BP)</strong>，是利用<strong>链式法则（chain rule）</strong>递归计算表达式的梯度的方法。</p><h3 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h3><p>对给定函数$f(x)$，其中$x$是输入数据的向量，需要计算函数$f$关于$x$的梯度$\nabla f(x)$。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在神经网络中，$f$ 对应的是损失函数 $L$，输入 $x$ 中包含训练数据和神经网络的权重。</p><p>例子：对于 SVM，损失函数是 SVM 的损失函数，输入包含了训练数据 $(x_i, y_i), i=1 … N$，权重 $W$，偏差 $b$。训练集是给定的，权重是可以控制（更新）的变量。因此，在实践上，尽管可以计算输入数据 $x_i$ 上的梯度，但是为了进行参数更新，通常只计算参数（如 $W, b$ ）的梯度。而 $x_i$ 的梯度在一些情形如可视化以直观理解时可以用上。</p><h3 id="从（标量）简单表达式引入"><a href="#从（标量）简单表达式引入" class="headerlink" title="从（标量）简单表达式引入"></a>从（标量）简单表达式引入</h3><p>考虑一个简单的二元乘法函数：</p><script type="math/tex; mode=display">f(x, y) = xy</script><p>对$x$和$y$分别求偏导数：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial x} = y \\\frac{\partial f}{\partial y} = x</script><p>（偏）导数的意义是，当函数变量在某个点周围的极小区域内变化，而导数是变量变化导致的函数在该方向上的变化率，数学定义如下：</p><script type="math/tex; mode=display">\frac{\partial f(x)}{\partial x} = \lim_{h \rightarrow 0}\frac{f(x+h) - f(x)}{h}</script><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>梯度$\nabla f$是偏导数的向量，因此（继续上面的例子）有：</p><script type="math/tex; mode=display">\nabla f = [\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}] = [y, x]</script><p>特别地，即使梯度实际上是一个向量，但通常仍会使用类似”$x$上的梯度“的（非正式）表述，而非”$x$的偏导数“的正确说法，这是因为前者更简单。</p><h4 id="对加法求偏导"><a href="#对加法求偏导" class="headerlink" title="对加法求偏导"></a>对加法求偏导</h4><script type="math/tex; mode=display">f(x, y)=x+y \rightarrow \frac{\partial f}{\partial x} = 1 \quad \frac{\partial f}{\partial y} = 1</script><h4 id="对-max-求导"><a href="#对-max-求导" class="headerlink" title="对$max$求导"></a>对$max$求导</h4><script type="math/tex; mode=display">f(x, y) = max(x, y) \rightarrow \frac{\partial f}{\partial x} = 1 (x \ge y) \quad \frac{\partial f}{\partial y} = 1 (y \ge x)</script><p>该式说明如果该变量比另一个大，则梯度是 $1$，反之为 $0$。</p><h3 id="使用链式法则计算复合表达式"><a href="#使用链式法则计算复合表达式" class="headerlink" title="使用链式法则计算复合表达式"></a>使用链式法则计算复合表达式</h3><p>对于复杂的包含多个函数的复合函数，如：</p><script type="math/tex; mode=display">f(x, y, z) = (x+y)z</script><p>可以将其拆分为两个部分：</p><script type="math/tex; mode=display">q = x + y \quad f = qz</script><p>对其分别求偏导：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial q} = z \quad \frac{\partial f}{\partial z} = q \\\frac{\partial q}{\partial x} = 1 \quad \frac{\partial q}{\partial y} = 1</script><p>值得注意的是，$q$ 是我们构造的中间量，我们实际上不关心 $q$（即，不关心 $\frac{\partial f}{\partial q}$），而关心 $f$ 关于 $x,y,z$ 的梯度。<strong>链式法则（chain rule）</strong>给出了对于求解 $f$ 关于 $x,y,z$ 梯度表达式的方式：通过相乘。如：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial x} = \frac{\partial f}{\partial q} \frac{\partial q}{\partial x}</script><h4 id="计算图例子"><a href="#计算图例子" class="headerlink" title="计算图例子"></a>计算图例子</h4><p><img src="213da7f66594510b45989bd134fc2d8b_720w.jpeg" alt="img"></p><ul><li><p>前向传播（forward pass）：<strong>绿色</strong>数字是量的值（ $x,y,z$ 的初始值是我们设定的，没有特殊含义），从左到右（前向）进行依次通过算子（节点（node）/门（gate））</p></li><li><p>反向传播（backword pass）：<strong>红色</strong>数字是 $f$ 相对于当前变量（假定为 $u$ ）的梯度，从右到左（反向/后向）依次通过算子进行链式法则。$f$ 的梯度初始值是 $1$，这是因为 $\frac{\partial f}{\partial f} = 1$</p></li></ul><h4 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h4><p>每个节点（node），也叫做门（gate），具有前向传播和反向传播两种计算：</p><ul><li>前向传播计算：输入是若干节点的值，输出是经过该节点的运算结果。如上图中$+$门的两个输入是 $-2$ 和 $5$，输出是 $-2+5=3$</li><li>反向传播计算：输入是链式法则上一步的梯度，输出是链式法则的下一步梯度。如上图中$\times$门的输入是 $1$，输出有两个分支方向，对于 $q$ 方向，由于 $\times$ 运算的偏导数是对方（如$f(x, y) = xy \quad \frac{\partial f}{\partial x} = y \quad<br>\frac{\partial f}{\partial y} = x$），因此局部梯度为 $z$ 即为 $-4$，因此链式法则的下一步梯度得到 $1 \times (-4) = -4$；对于 $z$ 方向，由于 $\times$ 运算的偏导数是对方，因此局部梯度为 $q$ 即为$3$，因此链式法则的下一步梯度得到 $1 \times 3 = 3$</li></ul><p>反向传播可以看作门单元之间在通过梯度信号相互通信。</p><h3 id="模块化：以-Sigmoid-为例"><a href="#模块化：以-Sigmoid-为例" class="headerlink" title="模块化：以  $Sigmoid$  为例"></a>模块化：以  $Sigmoid$  为例</h3><p>上面的例子比较直观，我们给出对门更精确的描述：任何可微函数都可以看作门，可以将多个门组合成一个门，也可以根据需求将一个门拆分为多个门。一个复杂的例子：</p><script type="math/tex; mode=display">f(w,x) = \frac{1}{1 + e^{-(w_0x_0+w_1x_1+w_2)}}</script><p>事实上，这个表达式描述了一个含输入$x$和权重$w$的2维神经元，使用了 $Sigmoid$  激活函数。</p><p>除了上文的加法门、乘法门和 $max$ 门，还有下述门：</p><script type="math/tex; mode=display">f(x)=\frac{1}{x} \rightarrow \frac{df}{dx}= -\frac{1}{x^2}</script><script type="math/tex; mode=display">f_c(x)=c+x\rightarrow \frac{df}{dx}=1</script><script type="math/tex; mode=display">f(x)=e^x \rightarrow \frac{df}{dx}=e^x</script><script type="math/tex; mode=display">f_a(x)=ax \rightarrow \frac{df}{dx} = a</script><h4 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h4><p><img src="0799b3d6e5e92245ee937db3c26d1b80_720w.webp" alt="img"></p><h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="$Sigmoid$"></a>$Sigmoid$</h4><p>$Sigmoid$ 函数也被记为 $\sigma (x)$，形式如下：</p><script type="math/tex; mode=display">\sigma (x) = \frac{1}{1 + e^{-x}}</script><p>求导结果为：</p><script type="math/tex; mode=display">\frac{d \sigma (x)}{dx} = \frac{e^{-x}}{(1+e^{-x})^2}=(\frac{1+e^{-x}-1}{1+e^{-x}})(\frac{1}{1+e^{-x}})=(1 - \sigma (x))(\sigma(x))</script><p>因此，可以将原式转为：</p><script type="math/tex; mode=display">q = w_0x_0+w_1x_1+w_2 \\f(q) = \frac{1}{1+e^{-q}} = \sigma (q)</script><p>因此，将原来计算图中的 $*-1,exp,+1,\frac{1}{x}$ 合并为 $\sigma $，一次性算出 $(1-0.73) \times 0.73=0.20$ ，这也说明我们可以根据需求将多个门合并为一个门，也可以将一个门拆分为多个门。</p><h3 id="回传流中的模式"><a href="#回传流中的模式" class="headerlink" title="回传流中的模式"></a>回传流中的模式</h3><p>多数时候，反向传播中的梯度可以被直观地解释。</p><h4 id="加法门"><a href="#加法门" class="headerlink" title="加法门"></a>加法门</h4><p>将输出的梯度相等地分发给所有输入，与输入值在前向传播时的值无关。</p><h4 id="max-门"><a href="#max-门" class="headerlink" title="$max$ 门"></a>$max$ 门</h4><p>$max$ 门将梯度转给其中一个输入，该输入是前向传播中值最大的那个输入。</p><h4 id="乘法门"><a href="#乘法门" class="headerlink" title="乘法门"></a>乘法门</h4><p>乘法门的局部梯度就是相互交换的输入值，然后根据链式法则乘以输出值的梯度。</p><h3 id="对向量操作计算梯度"><a href="#对向量操作计算梯度" class="headerlink" title="对向量操作计算梯度"></a>对向量操作计算梯度</h3><p>之前引入的内容都考虑的单个变量，但所有概念都适用于矩阵和向量操作。值得注意的是，操作时需要注意维度和转置操作。</p><h4 id="矩阵相乘的梯度"><a href="#矩阵相乘的梯度" class="headerlink" title="矩阵相乘的梯度"></a>矩阵相乘的梯度</h4><p>一个有用的技巧：矩阵（向量）的尺寸（维度）和其梯度是一致的，据此我们可以知道如何使维度相符合。比如，$X$的尺寸是$[10, 3]$， $dD$的尺寸是 $[5, 3]$，如果想要 $dW$ 和 $W$ 的尺寸是 $[5, 10]$ ，那么需要 $dD.dot(X.T)$</p><h2 id="Part-2-神经网络"><a href="#Part-2-神经网络" class="headerlink" title="Part 2 神经网络"></a>Part 2 神经网络</h2><h3 id="线性分类与神经网络"><a href="#线性分类与神经网络" class="headerlink" title="线性分类与神经网络"></a>线性分类与神经网络</h3><p>在之前的<strong>线性分类</strong>笔记中，我们使用了 $s=Wx$ 来计算不同视觉类别的评分，其中 $W$ 是一个权重矩阵， $x$ 是一个包含了图像的全部像素数据的输入列向量。具体地，在CIFAR-10中， $x$ 是 $[3072 \times 1]$ 的列向量，$W$ 是 $[10 \times 3072]$ 的矩阵，输出的评分是 $[10 \times 1]$ 列向量，表示 $10$ 个分类的评分。</p><p>而<strong>神经网络</strong>有所不同，（一个两层神经网络，2-layer Neural Net）的计算公式是：</p><script type="math/tex; mode=display">s=W_2max(0,W_1x)</script><p>其中， $W_1$ 的含义是：如，它可以是一个 $[100\times 3072]$ 的矩阵，可以将图像转为一个 $[100 \times 1]$ 的过渡向量。</p><p>函数 $max(0, -)$ 是非线性的，会作用于每个元素，称为<strong>激活函数</strong>，它的选择有很多种。在这里， $max$ 函数简单地设置了阈值，将所有小于 $0$ 的值变为 $0$ 。</p><p>矩阵 $W_2$ 的尺寸是 $[10 \times 100]$ ，最终可以得到一个 $[10 \times 1]$ 的列向量，每个元素（数字）可以解释为分类的评分。</p><p>在上面，我们注意到神经网络和线性分类的重要区别在于非线性函数。假如没有非线性函数，那么两个矩阵会乘在一起，合并为一个矩阵，那么就会重新变成线性函数（分类）。因此，这个非线性函数就是变化的关键。</p><p>参数 $W_1$ 和 $W_2$ 会通过随机梯度下降来学习，他们的梯度在反向传播中通过链式法则求导计算。</p><p>类似地，三层神经网络可以看做：</p><script type="math/tex; mode=display">s=W_3 max(0, W_2max(0, W_1x))</script><p>其中， $W_1, W_2, W_3$ 是需要进行学习的参数，中间隐层（hidden layer）的尺寸是网络的<strong>超参数</strong>，后续会学习如何设置。</p><h3 id="神经元（Neuron）"><a href="#神经元（Neuron）" class="headerlink" title="神经元（Neuron）"></a>神经元（Neuron）</h3><p>神经网络算法最开始是受到生物神经系统建模的启发，但是很快与其分道扬镳，成为一个工程问题。因此，这方面的讨论局限于高度抽象的简略描述，不做过多的类比牵连。</p><h4 id="连接与信号"><a href="#连接与信号" class="headerlink" title="连接与信号"></a>连接与信号</h4><p><img src="neuron.jpg" alt="neuron"></p><p>左边是生物神经元，右边是（神经网络中的）神经元计算模型。</p><ul><li>生物模型中，每个神经元从<strong>树突</strong>获得输入信号，沿着<strong>唯一轴突</strong>产生输出信号。轴突在末端会分支，通过突触和其他神经元的树突相连。</li><li>计算模型中，沿着轴突传播的信号（这里是 $x_0$），传播至下一个神经元时，会基于突触的强度（这里是 $w_0$），和该神经元的树突进行乘法交互（这里是 $w_0x_0$）。这里，突触的强度（也就是权重 $w$ ）是可以学习的，而且可以控制一个神经元对另一个神经元影响的强度（还可以控制影响方向：使其兴奋（正权重）或抑制（负权重））</li><li>生物模型中，树突将信号传递到细胞体，信号在细胞体中相累加，如果和高于某个阈值，则神经元被<strong>激活</strong>，向其轴突输出一个峰值信号。</li><li>计算模型中，假设峰值信号的准确时间点不重要，重要的是激活信号的频率。这个基于<em>速率编码（firing rate）</em>的观点将神经元的激活率建模为<strong>激活函数（activation function）$f$ </strong>，表达轴突上的激活信号的频率。</li><li>历史上激活函数常选择使用 sigmoid 函数 $\sigma$，该函数输入实数值（求和后的信号值），将输入值压缩到 0-1 之间。</li></ul><h3 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h3><h4 id="Sigmoid-1"><a href="#Sigmoid-1" class="headerlink" title="$Sigmoid$"></a>$Sigmoid$</h4><p>$Sigmoid$ 公式如下：</p><script type="math/tex; mode=display">\sigma (x) = \frac{1}{1 + e^{-x}}</script><p>函数图像如下：</p><p><img src="sigmoid-function.png" alt="Sigmoid Function: - Artificial Intelligence"></p><p>$Sigmoid$ 函数输入实数值，并将其压缩到 $0$ 到 $1$ 的范围内。具体地，很大的负数变为 $0$ ，很大的正数变为 $1$ 。</p><p>$Sigmoid$ 对于神经元的激活频率有良好的解释：从完全不激活（$0$）到在求和后的最大频率处的完全饱和的激活（$1$）。尽管历史上比较常用，但是现在已经很少使用了，因为有两个主要缺点：</p><ul><li>$Sigmoid$ 函数饱和使梯度消失。当神经元的激活在接近 $0$ 或 $1$ 处时会饱和，梯度接近 $0$。由于反向传播时，局部梯度会和输出的梯度相乘，如果局部梯度很小（接近 $0$ ），那么相乘的结果会接近 $0$ ，这回“杀死”梯度。</li><li>$Sigmoid$ 函数的输出不是零中心的。</li></ul><h4 id="tanh"><a href="#tanh" class="headerlink" title="$tanh$"></a>$tanh$</h4><p>$tanh$ 公式如下：</p><script type="math/tex; mode=display">tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}} \\tanh(x)=2\sigma (2x) - 1</script><p>函数图像如下：</p><p><img src="R-C.png" alt="R-C"></p><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p>ReLU公式如下：</p><script type="math/tex; mode=display">f(x) = max(0,x)</script><blockquote><p>TODO</p></blockquote><h4 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h4><p>Leakly ReLU公式如下：</p><script type="math/tex; mode=display">f(x) = \mathbb{l} (x<0)(\alpha x) + \mathbb{l}(x \ge 0)(x)</script><blockquote><p>TODO</p></blockquote><h4 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h4><p>Maxout公式如下：</p><script type="math/tex; mode=display">max(w_{1}^{T}x+b_{1}, w_2^{T}x+b_2)</script><p>是 ReLU 和 Leakly ReLU 的一般化归纳。</p><blockquote><p>TODO</p></blockquote><h3 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h3><blockquote><p>学习神经网络结构非常重要，可以帮助阅读文献的架构图（笔者注）</p></blockquote><h4 id="分层组织（layer-wise-organization）"><a href="#分层组织（layer-wise-organization）" class="headerlink" title="分层组织（layer-wise organization）"></a>分层组织（layer-wise organization）</h4><p><strong>将神经网络算法以神经元的形式图形化</strong>。神经网络被建模成神经元的集合，神经元之间以无环图的形式进行连接。这也就是说，一些神经元的输出是另一些神经元的输入。神经网络中不允许循环，因为循环会导致前向传播（正向传播，forward pass）的无限循环。</p><p>通常，神经网络模型中的神经元是分层的，这不像生物神经元会聚合成大小不一的团状。对于普通的神经网络，最普通的层的类型是<strong>全连接层（fully-connected layer）</strong>。</p><p><img src="fully-connected layer.png" alt="fully-connected layer"></p><blockquote><p>左边是2层神经网络（2-layer neural network），右侧是3层神经网络（3-layer neural network）</p></blockquote><p>全连接层中的神经元与前后两层的神经元是完全成对连接的，但同一个全连接层内的神经元之间没有连接。</p><p>上图中左侧的2层神经网络的隐层（hidden layer）包含4个神经元（neural，也可以称为单元unit），输入层由3个神经元组成，输出层由2个神经元组成；右侧图是一个3层神经网络，有2个包含4个神经元的隐层。在这两个神经网络中，层与层之间的神经元是全连接的，但是层内的神经元不连接。</p><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>当说“N层神经网络（N-layer neural network）”时，并<strong>没有将输入层算入</strong>。因此，单层的神经网络是没有隐层的（指输入直接映射到输出）。因此，有人认为逻辑回归（logistic regression）和支持向量机（SVM）是一种单层神经网络（single-layer neural network）的特例。</p><p>人们也会使用人工神经网络（Artificial Neural Network, ANN）或多层感知器（Multi-Layer Perceptrons, MLP）来指代神经网络（Neural Network, NN）。</p><p>也有人不喜欢神经网络算法和人类大脑的类比，他们更倾向于使用单元（unit）而非神经元（neuron）作为术语。</p><h5 id="输出层（Output-layer）"><a href="#输出层（Output-layer）" class="headerlink" title="输出层（Output layer）"></a>输出层（Output layer）</h5><p>和神经网络中的其他层不同，输出层的神经元一般没有激活函数（或者认为有一个线性相等的激活函数）。这是因为最后的输出层大多用来表示分类评分值，因此是任意值的实数，或者某种实数值的目标数（比如在回归regession中）。</p><h5 id="确定网络尺寸（Sizing-neural-networks）"><a href="#确定网络尺寸（Sizing-neural-networks）" class="headerlink" title="确定网络尺寸（Sizing neural networks）"></a>确定网络尺寸（Sizing neural networks）</h5><p>用来度量神经网络尺寸的标准主要有两个：神经元个数和参数个数。以上图两个网络举例：</p><ul><li><p>左侧网络有 $4+2=6$ 个神经元（输入层不算），$[3 \times 4] + [4 \times 2]=20$ 个 权重（weights），$4+2=6$ 个偏置（bias），共 $26$ 个可学习的参数。</p></li><li><p>右侧网络有 $4+4+2=10$ 个神经元（输入层不算），$[3 \times 4]+[4 \times 4]+[4 \times 1]=32$ 个权重（weights）， $4+4+1=9$ 个偏置（bias），共 $41$ 个可学习的参数。</p></li></ul><p>常识：现代卷积神经网络能包含约1亿个参数，可由 $10-20$ 层构成（深度学习，deep learning）。然而，有效连接（effective connections）的个数因为参数共享的缘故大大增多，这在后面CNN的章节会详细介绍。</p><h4 id="前向传播计算举例（feed-forward-computation）"><a href="#前向传播计算举例（feed-forward-computation）" class="headerlink" title="前向传播计算举例（feed-forward computation）"></a>前向传播计算举例（feed-forward computation）</h4><p><img src="fully-connected layer.png" alt="fully-connected layer"></p><p><strong>不断重复的矩阵乘法和激活函数相交织。</strong></p><p>将神经网络组织成层状的一个重要原因，就是这个结构让神经网络算法使用矩阵向量操作变得简单和高效。以上图右侧的三层神经网络举例，输入是 $[3 \times 1]$ 的向量。<strong>一个层所有连接的强度（all connections strength）可以被存在一个单独的矩阵中</strong>。如第一个隐层权重 $W_1$ 是 $[4 \times 3]$ 的，所有单元的偏置储存在 $b_1$ 中，尺寸是 $[4 \times 1]$ 。这样，每个神经元的权重保存在 $W_1$ 的一个<strong>行</strong>中（这里笔者有结合神经元结构的思考，详见下面的注释），因此矩阵乘法 np.dot(W1,x) 可以计算该层所有神经元的激活数据。类似地， $W_2$ 是 $[4 \times 4]$ 矩阵，存储第二个隐层的连接强度，$W_3$ 是 $[1 \times 4]$ 用于输出层。因此可以总结，完成的 $3$ 层神经网络的前向传播就是简单的 $3$ 次矩阵乘法，交织着激活函数的应用。</p><blockquote><p>对于上图右侧的神经网络的第一个隐层（hidden layer 1），该层的每个神经元 $unit<em>{2,i}, i \in {1,2,3,4}$ （$unit</em>{2,i}$ 表示第 $2$ 层第 $i$ 个神经元）会接收来自上层的（这里是input layer）每个神经元传递的信号（如 $unit<em>{1,j}, j \in {1,2,3}$ ），以进行 $unit</em>{2,i}$ 的信号计算（$\sum<em>{j}w_jx_j, j \in {1,2,3}$，其中 $w_j$ 是 $unit</em>{2, i}$ 对上一层第 $j$ 个神经元的权重，$x_j$ 是上一层第 $j$ 个神经元传播出的信号）。因此，将 $w_j, j \in {1,2,3}$ 写成一个 $[3 \times 1]$ 的向量即为上文中描述的“ $W_1$ 中的一个行”。</p><p>因此， $W_1$ 的尺寸为 $[4 \times 3]$ 中，$4$ 指本层的神经元个数，$3$ 指上层的神经元个数。因此容易知道 $W_2$ 的尺寸是 $[4 \times 4]$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个3层神经网络的前向传播:</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">1.0</span>/(<span class="number">1.0</span> + np.exp(-x)) <span class="comment"># 激活函数(用的sigmoid)</span></span><br><span class="line">x = np.random.randn(<span class="number">3</span>, <span class="number">1</span>) <span class="comment"># 含3个数字的随机输入向量(3x1)</span></span><br><span class="line">h1 = f(np.dot(W1, x) + b1) <span class="comment"># 计算第一个隐层的激活数据(4x1)</span></span><br><span class="line">h2 = f(np.dot(W2, h1) + b2) <span class="comment"># 计算第二个隐层的激活数据(4x1)</span></span><br><span class="line">out = np.dot(W3, h2) + b3 <span class="comment"># 神经元输出(1x1)</span></span><br></pre></td></tr></table></figure><p>在上述代码中 $W_1, W_2, W_3, b_1, b_2, b_3$ 都是网络中可学习的参数。值得注意的是，$x$ 并不是一个单独的列向量，而可以是一个批量训练数据（其中每个输入样本会是 $x$ 中的一列），所有样本会被并行化地高效计算出来。</p><blockquote><p>全连接层的前向（正向）传播一般就是先进行一个矩阵乘法，然后加上偏置并使用激活函数。</p></blockquote><h4 id="表达能力"><a href="#表达能力" class="headerlink" title="表达能力"></a>表达能力</h4><p>理解全连接层神经网络的一个方式是，可以认为其定义了一个由一系列函数组成的函数族（family of functions），网络的权重是每个函数的参数。因此问题是：该函数族的表达能力如何？存在不能被神经网络表达的函数吗？</p><p>可以证明拥有至少一个隐层的神经网络是一个通用的近似器。对给定的任意连续函数 $f(x)$ 和任意 $\epsilon &gt; 0$，均存在至少含一个隐层的神经网络 $g(x)$ （且网络中有合理选择的非线性激活函数，如 sigmoid ），对于 $ \forall x$ ，使得 $|f(x) - g(x)|&lt;\epsilon$ 。换句话说，该神经网络可以近似任何连续函数。</p><p>既然一个隐层就能近似任何函数，那为什么还要构建更多层来将网络做得更深？答案是：虽然一个2层网络在数学理论上能完美地近似所有连续函数，但在实际操作中效果相对较差。在一个维度上，虽然以 $a,b,c$ 为参数向量“指示块之和”函数 $g(x)=\sum_{i}c_i \mathbb{l} (a_i &lt; x &lt; b_i)$ 也是通用的近似器，但是谁也不会建议在机器学习中使用这个函数公式。神经网络在实践中非常好用，是因为它们表达出的函数不仅平滑，而且对于数据的统计特性有很好的拟合。同时，网络通过最优化算法（例如梯度下降）能比较容易地学习到这个函数。类似的，虽然在理论上深层网络（使用了多个隐层）和单层网络的表达能力是一样的，但是就实践经验而言，深度网络效果比单层网络好。</p><p>另外，在实践中3层的神经网络会比2层的表现好，然而继续加深（做到4，5，6层）很少有太大帮助。卷积神经网络的情况却不同，在卷积神经网络中，对于一个良好的识别系统来说，深度是一个极端重要的因素（比如数十(以10为量级)个可学习的层）。对于该现象的一种解释观点是：因为图像拥有层次化结构（比如脸是由眼睛等组成，眼睛又是由边缘组成），所以多层处理对于这种数据就有直观意义。</p><h4 id="层的数量和尺寸"><a href="#层的数量和尺寸" class="headerlink" title="层的数量和尺寸"></a>层的数量和尺寸</h4><p>在面对一个具体问题的时候该确定网络结构呢？到底是不用隐层呢？还是一个隐层？两个隐层或更多？每个层的尺寸该多大？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「CS231n-Course-3」神经网络简介&quot;&gt;&lt;a href=&quot;#「CS231n-Course-3」神经网络简介&quot; class=&quot;headerlink&quot; title=&quot;「CS231n Course 3」神经网络简介&quot;&gt;&lt;/a&gt;「CS231n Course 3」</summary>
      
    
    
    
    
    <category term="CS231n" scheme="https://saltyfishyjk.github.io/tags/CS231n/"/>
    
    <category term="Deep Learning" scheme="https://saltyfishyjk.github.io/tags/Deep-Learning/"/>
    
    <category term="Machine Learning" scheme="https://saltyfishyjk.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>「CS231n Course 2」损失函数</title>
    <link href="https://saltyfishyjk.github.io/2023/05/23/%E3%80%8CCS231n-Course-2%E3%80%8D%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/05/23/%E3%80%8CCS231n-Course-2%E3%80%8D%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</id>
    <published>2023-05-23T02:43:06.000Z</published>
    <updated>2023-08-04T12:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「CS231n-Course-2」损失函数"><a href="#「CS231n-Course-2」损失函数" class="headerlink" title="「CS231n Course 2」损失函数"></a>「CS231n Course 2」损失函数</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>参考资料：</p><ul><li><a href="https://www.bilibili.com/video/BV1Gb4y1X7Q5?p=9&amp;vd_source=b0a8793490273b09808dbd6f72d3465c">b站 CS231n 3.1 损失函数</a></li><li><a href="https://zhuanlan.zhihu.com/p/20945670?refer=intelligentunit">知乎 线性分类笔记（中）</a></li><li><a href="https://zhuanlan.zhihu.com/p/21102293?refer=intelligentunit">知乎 线性分类笔记（下）</a></li><li><a href="https://zhuanlan.zhihu.com/p/21360434?refer=intelligentunit">知乎 最优化笔记（上）</a></li></ul><h2 id="Part-1-损失函数"><a href="#Part-1-损失函数" class="headerlink" title="Part 1 损失函数"></a>Part 1 损失函数</h2><p>损失函数，Loss Function，用于衡量我们对（评分函数给出的）结果的不满意程度。具体地，当评分函数输出结果和真实结果之间差异越大，损失函数越大，我们“越不满意”。</p><p>损失函数由多种形式，以下是一些常用损失函数。</p><h3 id="多类支持向量机损失（Multiclass-Support-Vector-Machine-Loss）"><a href="#多类支持向量机损失（Multiclass-Support-Vector-Machine-Loss）" class="headerlink" title="多类支持向量机损失（Multiclass Support Vector Machine Loss）"></a>多类支持向量机损失（Multiclass Support Vector Machine Loss）</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>SVM的损失函数希望SVM在正确分类上的得分始终比不正确分类上的得分高出一个边界值$\Delta$；如果满足，则损失值为0；如果不满足，则开始计算损失值。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>第$i$个数据包含图像$x_i$（的像素）和其正确的分类标签$y_i$。评分函数$f$对于输入像素数据，由公式$f(x_i, W)$计算不同分类类别的分值，记为$s$。如，对第$j$个类别的得分是$s_j=f(x_i, W)_j$，针对第$i$个数据的多类别SVM损失函数定义如下：</p><script type="math/tex; mode=display">L_i = \sum _{j \ne y_i}max (0, s_j - s_{y_i} + \Delta)</script><p>其中，$\Delta$是一个超参数，是某种“安全边距”。</p><p>举例而言，有三个分类，分值为$s = [13, -7, 11]$。第一个类别是正确类别，即，$y_i=0$，且我们假设$\Delta=10$，则根据上述公式代入计算得：</p><script type="math/tex; mode=display">L_i = max (0, -7-13+10)+max(0, 11 - 13 + 10) = 8</script><p>其中，</p><script type="math/tex; mode=display">max(0, -7 - 13 + 10)</script><p>$max$函数中，第一项是$0$，第二项是用第1个类别的（评分函数）得分减去正确类别（$y_i$，第0个类别）的得分，再加上超参数$\Delta$。可以这样理解：当对于该类别加上超参数$\Delta$（安全边距）后，正确类别（$y_i=0$）的得分仍高于该值，那么说明这一项没有损失，即取$max$函数的前项$0$；反之，说明正确类别并没有高出错误类别一个安全边距，则差值即为该项产生的损失。</p><p>特别地，线性评分函数如下：</p><script type="math/tex; mode=display">s = f(x_i, W) = W x_i</script><p>那么可以得到$s_j$即$s$的第$j$行为（注意，这里行列向量意会即可，似乎和上文中的并不符合）：</p><script type="math/tex; mode=display">s_j = w^{T}_{j}x_i</script><p>$s_{y_i}$为：</p><script type="math/tex; mode=display">s_{y_i} = w^{T}_{y_i}x_i</script><p>因此，SVM的损失函数可以表达为：</p><script type="math/tex; mode=display">L_i = \sum_{j \ne y_i}max(0, w_{j}^{T}x_i - w_{y_i}^{T}x_i+\Delta)</script><h4 id="折叶函数（hinge-loss）"><a href="#折叶函数（hinge-loss）" class="headerlink" title="折叶函数（hinge loss）"></a>折叶函数（hinge loss）</h4><p>hinge loss，也叫合页（损失）函数或折页（损失）函数（因为他长得像hinge）。它的表现形式如下：</p><script type="math/tex; mode=display">max(0, -)</script><p>一般情况下提到hinge loss即是如上的版本。特别地，有时候会使用平方折叶损失（即L2-SVM）</p><h3 id="正则化（Regularzition）"><a href="#正则化（Regularzition）" class="headerlink" title="正则化（Regularzition）"></a>正则化（Regularzition）</h3><p>在训练过程中，可能存在以下问题：</p><ul><li>$W$不唯一，很多相似的$W$可以正确分类所有数据</li><li>过拟合</li></ul><p>正则化即为某些特定的（也可以是全部）权重$W$添加一些偏好，对其他不添加，以消除模糊性。具体地，向损失函数增加一个正则化惩罚（regularition penalty）$R(W)$。</p><p>最常用的正则化惩罚是L2范式，对所有参数进行逐个元素的平方惩罚来抑制大数值的权重：</p><script type="math/tex; mode=display">R(W) = \sum_{k}\sum_{l}W_{k,l}^{2}</script><p>上式将$W$中所有元素平方后求和。完整的多类SVM损失函数如下：</p><script type="math/tex; mode=display">L = \frac{1}{N}\sum_{i}L_i+\lambda R(W)</script><p>其中，$\frac{1}{N}\sum_{i}L_i$是数据损失（data loss），即所有样例的平均损失；以及$\lambda R(W)$正则化损失（regularization loss）</p><h3 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="Softmax分类器"></a>Softmax分类器</h3><blockquote><p>关于Softmax函数的名字含义，可以这样理解：max函数仅输出最大值，而Softmax确保较小的值有较小的概率，不会直接丢弃，因此可以认为其是argmax函数的概率版本或soft版本</p></blockquote><p>SVM和Softmax分类器是最常用的两个分类器，Softmax分类器可以理解为逻辑回归分类器面对多个分类的一般化归纳。</p><p>Softmax的损失函数和SVM有所不同。具体地，SVM是将$f(x_i, W)$作为每个分类的评分，由于没有定标，因此难以解释含义。而Softmax的输出是归一化的分类概率，更加直观，而且可以从概率上解释。Softmax分类其中函数映射$f(x_i;W)=Wx_i$保持不变，但会对评分值<strong>视为每个分类的未归一化时的对数概率</strong>，根据这个表述，我们知道将该值先进行指数化，再归一化即可得到每个分类的概率。Softmax将SVM的折叶损失（hinge loss）替换为<strong>交叉熵损失（cross-entropy loss）</strong>：</p><script type="math/tex; mode=display">L_i = -log(\frac{e^{f_{y_i}}}{\sum_{j}e^{f_j}})或等价的L_i = -f_{y_i}+log(\sum_{j}e^f_j{})</script><p>上式中，各值的含义如下：</p><ul><li>$f_j$：分类评分向量$f$中的第$j$个元素</li></ul><p>和SVM相同，整个数据集的损失值是数据集中所有样本数据的损失值$L_i$的均值与正则化损失$R(W)$之和。其中，下式被称为Softmax函数：</p><script type="math/tex; mode=display">f_j(z)=\frac{s^{z_j}}{\sum_{k}e^{z_k}}</script><p>该函数的解释为：输入值是一个向量$z$，其元素为任意实数的评分值，函数对其进行压缩，输出一个向量，其中每个元素值在$0$和$1$之间，且所有元素之和为$1$。</p><h3 id="SVM和Softmax的比较"><a href="#SVM和Softmax的比较" class="headerlink" title="SVM和Softmax的比较"></a>SVM和Softmax的比较</h3><p><img src="a90ce9e0ff533f3efee4747305382064_r.jpg" alt="img"></p><p>首先，可以注意到两者的$f$在这里都使用了普通的矩阵乘法$W x_i$；</p><p>其次，观察到SVM对矩阵乘法的结果直接使用折叶损失函数（hinge loss），其中的超参数$\Delta$这里选择了$1$；</p><p>然后，观察到Softmax首先对$f$的结果取exp，然后进行归一化（得到各分类的概率），再然后取$-log$得到损失（对正确答案的分类概率进行$-log$）。</p><p>可以注意到，SVM对于”安全边距“以上的答案不予关心，认为损失为$0$，而由Softmax损失函数的计算公式可以知道，Softmax永远不会对答案满意，会不断调整来降低损失值。</p><blockquote><p>一个用于理解线性分类器和损失的<a href="http://vision.stanford.edu/teaching/cs231n-demos/linear-classify/">交互式网页</a></p></blockquote><h2 id="Part-2-优化"><a href="#Part-2-优化" class="headerlink" title="Part 2 优化"></a>Part 2 优化</h2><p>（最）优化，optimization，是寻找能使得损失函数值最小化的参数$W$的过程。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><h4 id="方案1：随机搜索"><a href="#方案1：随机搜索" class="headerlink" title="方案1：随机搜索"></a>方案1：随机搜索</h4><p>随机尝试很多不同的权重，看哪个最好，将其中表现最好的权重$W$取出。</p><p>这个方案不好，在验证集的表现是15.5%，比完全随机猜测的结果（10%）略好。</p><h4 id="方案2：随机本地搜索"><a href="#方案2：随机本地搜索" class="headerlink" title="方案2：随机本地搜索"></a>方案2：随机本地搜索</h4><p>每一个策略是每走一步随机尝试几个方向，若某个方向是向下的，则继续向这个方向走。具体地，从一个随机的$W$开始，生成一个随机的扰动$\delta W$，仅有$W + \delta W$的损失值变小时才更新。</p><h4 id="方案3：跟随梯度"><a href="#方案3：跟随梯度" class="headerlink" title="方案3：跟随梯度"></a>方案3：跟随梯度</h4><p>方案2中我们其实是在权重空间中尝试找到一个方向，使得沿着该方向可以降低。而梯度（gradient）恰好是这样一个数学概念，计算出某个点的各个方向的倾斜程度，以便选择最陡峭的方向下山。</p><p>一维函数种，斜率是某点的瞬时变化率；梯度是函数斜率的一般化表达，不是一个值，而是一个向量。在输入空间中，梯度是各个维度的斜率（偏导数）组成的向量。</p><p>具体地，一维函数的求导公式（定义式）如下：</p><script type="math/tex; mode=display">\frac{df(x)}{dx} = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h}</script><p>当函数有多个参数的时候，即非一维函数，此时改称偏导数。梯度就是每个维度上的偏导数为元素组成的向量。</p><h3 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h3><p>梯度计算主要有两种方法：</p><ol><li>数值梯度法：实现简单的近似方法，但是慢</li><li>分析梯度法：计算迅速，结果精准，但是实现时容易出错</li></ol><h4 id="数值梯度法"><a href="#数值梯度法" class="headerlink" title="数值梯度法"></a>数值梯度法</h4><p>取一个很小的$h$（实践中在$10^{-5}$级别），使用定义式计算。</p><p>优点：实现简单</p><p>缺点：是近似，有误差，计算开销大</p><h4 id="分析梯度法"><a href="#分析梯度法" class="headerlink" title="分析梯度法"></a>分析梯度法</h4><p>使用微分分析的方法计算梯度，结果精准且速度快，但是容易出错，实践中常常将分析梯度法的结果和数值梯度法的结果相比较，验证分析梯度实现的正确性，这个步骤叫做<strong>梯度检查（gradient check）</strong>。</p><p>以SVM的损失函数（hinge loss）为例：</p><script type="math/tex; mode=display">L_i = \sum_{j \ne y_i}[max(0, w_{j}^Tx_i - w_{y_i}^Tx_i+\Delta)]</script><p>对函数微分得：</p><script type="math/tex; mode=display">\nabla_{w_{y_i}}L_i = -(\sum_{j \ne y_i}\mathbb{l}(w_{j}^Tx_i - w_{y_i}^Tx_i+\Delta > 0))x_i</script><p>其中，$\mathbb{l}$是一个示性函数，即对括号内的条件进行判断，若为真，则式值为1，否则为0。该公式的意思为，计算（计数）没有满足安全边距的分类的数量（这些分类对损失函数产生了贡献），然后乘以$x_i$，即得到梯度。该公式是对应正确分类的$W$的行向量的梯度，那么$j \ne y_i$行的梯度是：</p><script type="math/tex; mode=display">\nabla_{w_j}L_i = \mathbb{l}(w_{j}^Tx_i - w_{y_i}^Tx_i+\Delta > 0)x_i</script><h4 id="小批量数据梯度下降（Mini-batch-gradient-descent）"><a href="#小批量数据梯度下降（Mini-batch-gradient-descent）" class="headerlink" title="小批量数据梯度下降（Mini-batch gradient descent）"></a>小批量数据梯度下降（Mini-batch gradient descent）</h4><p>大规模应用中的训练数据是百万量级的，训练成本很高，常用的方法是计算训练集中的小批量（batches）数据。如，在比较先进的CNN中，一个典型的小批量包含256个样本，而整个训练集的数量级在120万。</p><h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p>学习率，也叫步长，是神经网络训练中最重要的超参数设定之一。如果步长太小，则进度稳定但缓慢；若步长太大，进度快但有风险。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「CS231n-Course-2」损失函数&quot;&gt;&lt;a href=&quot;#「CS231n-Course-2」损失函数&quot; class=&quot;headerlink&quot; title=&quot;「CS231n Course 2」损失函数&quot;&gt;&lt;/a&gt;「CS231n Course 2」损失函数&lt;/</summary>
      
    
    
    
    
    <category term="CS231n" scheme="https://saltyfishyjk.github.io/tags/CS231n/"/>
    
    <category term="Deep Learning" scheme="https://saltyfishyjk.github.io/tags/Deep-Learning/"/>
    
    <category term="Machine Learning" scheme="https://saltyfishyjk.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>「CS231n Course 1」图像分类</title>
    <link href="https://saltyfishyjk.github.io/2023/05/22/%E3%80%8CCS231n-Course-1%E3%80%8D%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <id>https://saltyfishyjk.github.io/2023/05/22/%E3%80%8CCS231n-Course-1%E3%80%8D%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</id>
    <published>2023-05-22T11:48:33.000Z</published>
    <updated>2023-08-04T12:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「CS231n-Course-1」图像分类"><a href="#「CS231n-Course-1」图像分类" class="headerlink" title="「CS231n Course 1」图像分类"></a>「CS231n Course 1」图像分类</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p><a href="https://cs231n.github.io/">CS231n</a>全称为CS231n: Convolutional Neural Networks for Visual Recognition（2023学年），即《视觉识别的卷积神经网络》，广受欢迎和好评，是面向计算机视觉的深度学习课程，节奏对入门者比较友好。</p><p>笔者主要通过CS231n了解和学习深度学习，这一系列博客是个人学习笔记，会尽可能列出所有参考来源。</p><h3 id="学习和参考资料"><a href="#学习和参考资料" class="headerlink" title="学习和参考资料"></a>学习和参考资料</h3><ul><li><a href="http://cs231n.stanford.edu/">CS231n官网</a>：每次开课会更新，但是笔者没有学习最新的课程</li><li><a href="https://www.bilibili.com/video/BV1Gb4y1X7Q5/?vd_source=b0a8793490273b09808dbd6f72d3465c">b站2017年录播（双语字幕）</a>：主要网课参考</li><li><a href="https://zhuanlan.zhihu.com/p/21930884">知乎2016年授权笔记翻译集</a>：主要笔记参考</li><li><a href="https://zhuanlan.zhihu.com/p/20894041?refer=intelligentunit">知乎 图像分类笔记（上）</a>：本篇博客重要参考</li><li><a href="https://zhuanlan.zhihu.com/p/20900216">知乎 图像分类笔记（下）</a>：本篇博客重要参考</li><li><a href="https://zhuanlan.zhihu.com/p/20918580?refer=intelligentunit">知乎 线性分类笔记（上）</a>：本篇博客重要参考</li></ul><h2 id="Part-1-数据驱动"><a href="#Part-1-数据驱动" class="headerlink" title="Part 1 数据驱动"></a>Part 1 数据驱动</h2><p>图像分类问题中随着视角/大小/形状等的变化，可以让一个物体的图片产生巨大变化（把图像当作3维数组），这不利于编写一个算法来判断某张图像是否是一个“猫”。</p><p>数据驱动的方法从数据出发，输入一个元素为像素值的数组，给其分配一个分类标签。完整流程：</p><ul><li>输入：包含N个图像的集合，包含图像和其对应的K种分类标签中的一种。该集合称为训练集。</li><li>学习：使用训练集学习每个类应该是什么样的。该步骤一般称为训练分类器或学习一个模型。</li><li>评价：让分类器预测一个未曾见过的图像的分类标签，并以此评价分类器的质量。</li></ul><h2 id="Part-2-K-Nearest-Neighbour分类器（NN和KNN）"><a href="#Part-2-K-Nearest-Neighbour分类器（NN和KNN）" class="headerlink" title="Part 2 (K) Nearest Neighbour分类器（NN和KNN）"></a>Part 2 (K) Nearest Neighbour分类器（NN和KNN）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>训练集：用来学习一个(K)NN模型的带标签数据（图像-标签 pair）</li><li>测试集：用模型预测测试集（不在训练集中出现过）的图像的分类标签</li><li>距离函数：包含曼哈顿距离（L1距离）、欧几里得距离（L2距离）等，用来评价图像之间的相似程度。</li><li>准确率：评价模型预测的得分</li><li>超参数（Hyperparameter）：在开始机器学习之前就人为设置好的参数。用于区别于模型参数这一通过训练得到的参数。具体地，KNN中K的选择就是一种超参数，距离函数的选择也是一种超参数。</li></ul><h3 id="NN和KNN"><a href="#NN和KNN" class="headerlink" title="NN和KNN"></a>NN和KNN</h3><ul><li>NN：通过给定的训练集，将测试集中的元素和训练集中的每一个元素计算”距离“，选择和其”距离“最小的图像的标签作为该测试集元素的标签</li><li>KNN：NN是找和未知图像最像（距离越小，约”像“）的已知图像，将其标签作为未知图像的标签；KNN是找和未知图像最想的K个图像的标签，使其投票，将票数最高的标签作为对未知图像的预测。</li></ul><h3 id="可视化示意图"><a href="#可视化示意图" class="headerlink" title="可视化示意图"></a>可视化示意图</h3><p><img src="51aef845faa10195e33bdd4657592f86_r.jpg" alt="img"></p><ul><li>颜色区域：不同颜色代表不同分类</li><li>点：每个标注出的点是一个训练数据，其颜色表示其分类标签；整张图中未标注点的部分为非训练数据，即，真实数据可能出现在任何一个未标注的点处，这里的颜色代表该(K)NN模型会将其预测为的分类。可以注意到，这里的点并非图像中的像素点，而是代表了一个高维数据（如一张图片）</li><li>可以注意到，KNN的表现更加平滑</li></ul><p>实际上，(K)NN工作时是先储存了所有训练数据，在test时将test数据和每一份训练数据计算距离并比较。因此，实际上训练过程是$O(1)$的（其实并没有做计算，只是把数据存储起来了），而预测过程是$O(n)$的（和训练数据中的每一个元素匹配）。</p><p>一个可以交互的KNN 玩具模型：<a href="http://vision.stanford.edu/teaching/cs231n-demos/knn/">http://vision.stanford.edu/teaching/cs231n-demos/knn/</a></p><h3 id="超参数调优"><a href="#超参数调优" class="headerlink" title="超参数调优"></a>超参数调优</h3><p><img src="image-20230522214923716.png" alt="image-20230522214923716"></p><p><img src="image-20230522221016320.png" alt="image-20230522221016320"></p><p>不好的做法：</p><ul><li>选择整个数据集（全部为训练集）上表现最好的：如KNN的K=1时准确率为100%，但这不是一个更优的策略</li><li>将数据划分为训练集（train）和测试集（test），选择在测试集上表现最好的：不知道算法会在新数据上表现如何</li></ul><p>不错的做法：</p><ul><li>将数据划分为训练集（train）、验证集（validation）和测试集（test）：选择在验证集上表现最好的，并用其在test上测试来评估</li><li>交叉验证，将数据分为不同fold和测试（test），循环将不同fold作为验证（validation）：适合小数据集，不适合深度学习（训练成本过高）</li></ul><h2 id="Part-3-线性分类"><a href="#Part-3-线性分类" class="headerlink" title="Part 3 线性分类"></a>Part 3 线性分类</h2><p>简单直观的分类方法，但是对建立神经网络和卷积网络非常重要。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>评分函数（score function）：原始图像数据到类别分值的映射。即，input 原始图像数据，output该图像数据到（各）类别的分值，得分高低代表图像属于该类的可能性高低。</li><li>损失函数（loss function）：量化预测分类标签的得分和真实标签之间的一致性。该问题可以转化为一个最优化问题，即，通过更新评分函数的参数来使得最小化损失函数值。</li></ul><h3 id="评分函数"><a href="#评分函数" class="headerlink" title="评分函数"></a>评分函数</h3><p>评分函数是一个从图像到标签分值的参数化映射。</p><p>我们有$N$个训练图像，每个图像的维度是$D$，共有$K$种不同的分类，可以表示如下：</p><ul><li>训练集：若干张图像，可以表示为$x_i \in R^D$</li><li><p>分类标签：$y_i, i = 1, 2, …,N$且$y_i \in 1 … K$</p></li><li><p>评分函数：$f:R^D \rightarrow R^K$：原始图像像素到分类分值的映射</p></li></ul><p>注意，这里图像维度是$D$的意思可以这样解释：图像的尺寸规格是$32 \times 32 \times 3$，则$D=32 \times 32 \times 3 = 3072$（这里适合用<code>NumPy</code>提供的<code>reshape</code>函数将图像矩阵转为列向量）。事实上，这已经属于“高维度”向量和向量空间了，但是我们依然用二维平面和线性函数（直线型）的概念做直观理解。</p><h3 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h3><script type="math/tex; mode=display">f(x_i, W, b)=Wx_i+b</script><p>该公式中，每个图像数据都被拉长为长度为$D$的列向量，大小为$[D \times 1]$，其中大小为$[K \times D]$的矩阵$W$和大小为$[K \times 1]$的列向量$b$是该函数的参数。</p><ul><li>参数：$W$和$b$，也会被称为权重</li><li>$W$：权重（weights）。大小为$[K \times D]$，$K$行$N$列，每一行（行向量）表示一个分类器，针对一个分类，共针对$K$个分类。</li><li>$b$：偏差向量（bias vector）。假如我们预先知道数据中“猫”多于“狗”，那么可以给“猫”对应的类别设置更大的偏差值来表示对其的偏好</li><li>$W$和$b$是可变的，会在训练中迭代变化。一旦训练完成，训练数据可以丢弃，仅留下学习到的$W$和$b$参数即可用于测试，这是区别于KNN的一点。</li></ul><blockquote><p>卷积神经网络映射图像像素值到分类分值的方法和上面类似，但是映射$f$要复杂一些，参数要更多</p></blockquote><h3 id="偏差和权重的合并技巧"><a href="#偏差和权重的合并技巧" class="headerlink" title="偏差和权重的合并技巧"></a>偏差和权重的合并技巧</h3><p>$f(x_i, W, b)=Wx_i+b$看起来有些笨重，可以将$x_i$和$W$增加一个维度，称为默认的偏差维度，将其化简为：</p><script type="math/tex; mode=display">f(x_i, W)=Wx_i</script><p>具体地，之前的$x_i$是$[3072 \times 1]$，调整后变为$[3073 \times 1]$；之前的$W$是$[10 \times 3072]$，调整后变为$[10 \times 3073]$，具体如下：</p><p><img src="3c69a5c87a43bfb07e2b59bfcbd2f149_r.jpg" alt="img"></p><h3 id="图像数据预处理"><a href="#图像数据预处理" class="headerlink" title="图像数据预处理"></a>图像数据预处理</h3><p>之前的例子中都是使用的图像的原始像素值。而对于输入特征的归一化处理非常常见和重要，如零均值的中心化。这一部分会和梯度下降相关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「CS231n-Course-1」图像分类&quot;&gt;&lt;a href=&quot;#「CS231n-Course-1」图像分类&quot; class=&quot;headerlink&quot; title=&quot;「CS231n Course 1」图像分类&quot;&gt;&lt;/a&gt;「CS231n Course 1」图像分类&lt;/</summary>
      
    
    
    
    
    <category term="CS231n" scheme="https://saltyfishyjk.github.io/tags/CS231n/"/>
    
    <category term="Deep Learning" scheme="https://saltyfishyjk.github.io/tags/Deep-Learning/"/>
    
    <category term="Machine Learning" scheme="https://saltyfishyjk.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>「BUAA Computer Network Experiment」Notes</title>
    <link href="https://saltyfishyjk.github.io/2023/05/11/%E3%80%8CBUAA-Computer-Network-Experiment%E3%80%8DNotes/"/>
    <id>https://saltyfishyjk.github.io/2023/05/11/%E3%80%8CBUAA-Computer-Network-Experiment%E3%80%8DNotes/</id>
    <published>2023-05-11T12:33:32.000Z</published>
    <updated>2023-05-25T14:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「BUAA-Computer-Network-Experiment」Notes"><a href="#「BUAA-Computer-Network-Experiment」Notes" class="headerlink" title="「BUAA Computer Network Experiment」Notes"></a>「BUAA Computer Network Experiment」Notes</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>线下实验室和线上网络实验室的设备版本和指令有少量区别，下文中多数<em>特殊说明</em>的情况是针对线下实验室环境<del>毕竟考试也要在线下</del>。另外，不同套件的实验顺序和内容也有所不同，下文均指套件二。</p><p>本笔记可能并不全面，不能作为jwsy的指导书使用，读者仍需结合ppt、常见问题解答、教材等学习。</p><h2 id="Part-1-实验一-网络实验入门"><a href="#Part-1-实验一-网络实验入门" class="headerlink" title="Part 1 实验一 网络实验入门"></a>Part 1 实验一 网络实验入门</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>对于路由器和交换机，其在不同视图下执行不同指令，主要分为<strong>用户视图</strong>和<strong>系统视图</strong>。</p><h4 id="用户视图"><a href="#用户视图" class="headerlink" title="用户视图"></a>用户视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3c&gt;</span><br></pre></td></tr></table></figure><h4 id="系统视图"><a href="#系统视图" class="headerlink" title="系统视图"></a>系统视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3c&gt;system-view // 由用户视图进入系统视图</span><br><span class="line">[h3c]</span><br></pre></td></tr></table></figure><h3 id="清空网络设备配置"><a href="#清空网络设备配置" class="headerlink" title="清空网络设备配置"></a>清空网络设备配置</h3><p>在实验开始之前，一定记得清空网络设备（路由器和交换机）的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3c&gt;reset saved-configuration // 删除已保存的配置，选y</span><br><span class="line">&lt;h3c&gt;reboot // 重启设备，先选n再选y</span><br></pre></td></tr></table></figure><h3 id="display"><a href="#display" class="headerlink" title="display"></a><code>display</code></h3><p>查看当前配置，可以在任意视图下使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3c&gt;dis cu // display current-confiiguration的缩写，查看系统当前的配置</span><br><span class="line">&lt;h3c&gt;display version // 查看当前系统版本</span><br><span class="line">[h3c]display interface g 1/0/1 // 查看千兆以太网端口1/0/1的信息</span><br></pre></td></tr></table></figure><blockquote><p>注意，不同网络设备（如线下和线上）的接口编号可能有所不同，需要使用dis cu显示当前设备的各接口编号，根据实际设备编号调整命令</p><p>技巧：<code>dis cu</code>后可能行数较多不能一次显示完整，此时使用空格键会放出接下来的一屏，使用回车键会放出接下来的一行</p></blockquote><h3 id="进入指定以太网接口视图"><a href="#进入指定以太网接口视图" class="headerlink" title="进入指定以太网接口视图"></a>进入指定以太网接口视图</h3><p>配置路由器/交换机接口时，往往需要先进入接口视图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]inter g 0/0 // interface g 0/0的缩写，进入编号为0/0的千兆以太网口</span><br></pre></td></tr></table></figure><h3 id="配置以太网接口IP"><a href="#配置以太网接口IP" class="headerlink" title="配置以太网接口IP"></a>配置以太网接口IP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt;system-view // 进入系统视图</span><br><span class="line">[R1]inter g 0/0 // interface g 0/0的缩写，进入千兆以太网接口0/0</span><br><span class="line">[R1-...0/0]ip address 192.168.0.1 24 // 配置该接口的IP地址为192.168.0.1，子网掩码为255.255.255.0，和ip address 192.168.0.1 255.255.255.0是等价的</span><br></pre></td></tr></table></figure><h3 id="NAT地址转换"><a href="#NAT地址转换" class="headerlink" title="NAT地址转换"></a>NAT地址转换</h3><p><img src="image-20230518110848408.png" alt="image-20230518110848408"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[R1]acl basic 2001 // 在V7设备中（线下设备），使用acl basic命令；在V5设备中（线上设备），使用acl number命令</span><br><span class="line">[R1-acl-2001]rule permit source 10.0.0.0 0.0.0.255</span><br><span class="line">[R1-acl-2001]rule deny sourse any // 允许IP源地址为10.0.0.0/24的外出数据包</span><br><span class="line">[R1]nat address-group 1</span><br><span class="line">[R1-address-group-1]address 192.168.5.105 192.168.5.109 // 定义一个包含5个公网地址的地址池，地址池名为1</span><br><span class="line">[R1]interface e 1/0/1</span><br><span class="line">[R1-Ethernet 1/0/1]nat outbound 2001 address-group 1 // 在出接口e 1/0/1启动地址转换</span><br><span class="line">[R1]ip route-static 0.0.0.0 0.0.0.0 192.168.5.1 // 在路由表添加静态路由</span><br></pre></td></tr></table></figure><h3 id="当和OSPF等相结合时，需要通告默认路由"><a href="#当和OSPF等相结合时，需要通告默认路由" class="headerlink" title="当和OSPF等相结合时，需要通告默认路由"></a><strong>当和OSPF等相结合时，需要通告默认路由</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]ospf // 进入ospf</span><br><span class="line">[R1-ospf-1]default-route-advertise cost 100 // 通告默认路由配置</span><br></pre></td></tr></table></figure><h2 id="Part-2-数据链路层实验"><a href="#Part-2-数据链路层实验" class="headerlink" title="Part 2 数据链路层实验"></a>Part 2 数据链路层实验</h2><h3 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h3><p>VLAN，虚拟局域网，是数据链路层划分局域网的重要技术，用于划分广播域。</p><h4 id="基于端口的划分"><a href="#基于端口的划分" class="headerlink" title="基于端口的划分"></a>基于端口的划分</h4><p>基于端口的划分，具体指基于交换机端口的划分，指交换机的某些端口连接的主机在一个广播域内，另一些端口连接的主机在另一个广播域内。即，VLAN和端口所连接的主机无关。</p><p>目前的主机都不支持带有tag域的以太网数据帧，即，认为带有tag的以太网数据帧为非法帧，只能发送和接收标准以太网数据帧。因此，交换机将数据发送给主机的时候必须删除tag域。</p><h4 id="基于子网的划分"><a href="#基于子网的划分" class="headerlink" title="基于子网的划分"></a>基于子网的划分</h4><p>根据主机使用的IP地址所在的网络子网来划分广播域，即，IP地址属于同一个子网的主机属于同一个广播域。</p><h4 id="VLAN端口的分类"><a href="#VLAN端口的分类" class="headerlink" title="VLAN端口的分类"></a>VLAN端口的分类</h4><p>交换机的端口可以分为Access, Trunk和Hybrid三类。</p><ul><li>Access：连接不支持VLAN技术的终端设备（如主机）的（交换机）端口</li><li><p>Trunk：连接支持VLAN技术的网络设备（如交换机）的（交换机）端口，收到的数据一般带有VLAN标签（数据帧VLAN和端口默认VLAN ID相同的除外）；向外发送数据帧时，须保证接收端可以区分不同的VLAN，因此常常需要添加VLAN标签（数据帧VLAN ID和端口默认VLAN ID相同的除外），一般<strong>用于交换机之间的连接</strong>。</p></li><li><p>Hybrid：Access和Trunk的混合模式，在Hybrid下工作的端口可以属于多个VLAN，可以接收和发送多个VLAN的报文，可以用于交换机之间的连接，也可以用于连接用户。</p></li></ul><h4 id="默认VLAN"><a href="#默认VLAN" class="headerlink" title="默认VLAN"></a>默认VLAN</h4><p>每个（交换机）端口的属性，值为pvid，可以人为设置。交换机从某个端口收到一个不带VLAN标签的数据帧的时候，会在交换机内部将该数据帧视为带默认VLAN标签的数据帧。</p><p>H3C交换机初始化时，将每个端口设置为VLAN1，且VLAN1是每个端口的默认VLAN(pvid=1)，VLAN1是untagged的。</p><h4 id="带标签（tagged）和不带标签（untagged）"><a href="#带标签（tagged）和不带标签（untagged）" class="headerlink" title="带标签（tagged）和不带标签（untagged）"></a>带标签（tagged）和不带标签（untagged）</h4><p>tagged和untagged是端口的VLAN属性，用于确定从该端口发出的数据帧是否带VLAN标签。</p><p>一般来说，Access端口是untagged的；Trunk端口只有默认VLAN才是untagged，其他端口都是tagged；Hybrid端口比较灵活，可以自由设置。</p><h3 id="配置VLAN"><a href="#配置VLAN" class="headerlink" title="配置VLAN"></a>配置VLAN</h3><h4 id="创建-删除VLAN"><a href="#创建-删除VLAN" class="headerlink" title="创建/删除VLAN"></a>创建/删除VLAN</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c]vlan 2 // 创建vlan 2，2可以替换为其他vlan id，执行后会变为[h3c-vlan2]</span><br><span class="line">[h3c]undo vlan 2// 删除vlan 2，2可以替换为其他vlan id</span><br></pre></td></tr></table></figure><h4 id="向VLAN中添加-删除端口"><a href="#向VLAN中添加-删除端口" class="headerlink" title="向VLAN中添加/删除端口"></a>向VLAN中添加/删除端口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[h3c]vlan 2 // 创建/进入 vlan 2</span><br><span class="line">[h3c-vlan2]port e 1/0/1 to e 1/0/3 // 进入vlan后，使用port ... to ...将某一范围内的端口添加到该VLAN，使用的是基于端口的VLAN划分。需要注意的是，e是Ethernet的缩写，线下网络实验室应当使用g</span><br><span class="line">[h3c-vlan2]undo port e 1/0/1 to e 1/0/2 // 将e 1/0/1 to e 1/0/3从VLAN2中删除</span><br></pre></td></tr></table></figure><h4 id="指定端口类型"><a href="#指定端口类型" class="headerlink" title="指定端口类型"></a>指定端口类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[h3c]int e 1/0/1 // 首先进入指定的端口</span><br><span class="line">[h3c-Ethernet 1/0/1]port link-type trunk // 将端口类型设置为trunk</span><br><span class="line">[h3c-Ethernet 1/0/1]undo port link-type // 取消端口类型设置</span><br><span class="line">[h3c-Ethernet 1/0/1]port link-type hybrid // 将端口类型设置为hybrid</span><br></pre></td></tr></table></figure><h4 id="指定-删除端口的默认VLAN-ID"><a href="#指定-删除端口的默认VLAN-ID" class="headerlink" title="指定/删除端口的默认VLAN ID"></a>指定/删除端口的默认VLAN ID</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[h3c]int e 1/0/1 // 首先进入指定的端口</span><br><span class="line">[h3c-Ethernet 1/0/1]port trunk pvid vlan 2// 指定端口默认VLAN ID为2</span><br><span class="line">[h3c-Ethernet 1/0/1]undo port trunk pvid vlan // 删除端口的默认VLAN ID</span><br></pre></td></tr></table></figure><h4 id="指定-删除Trunk端口可以通过的VLAN数据帧"><a href="#指定-删除Trunk端口可以通过的VLAN数据帧" class="headerlink" title="指定/删除Trunk端口可以通过的VLAN数据帧"></a>指定/删除Trunk端口可以通过的VLAN数据帧</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c-Ethernet 1/0/1]port trunk permit vlan 2 to 3 // 允许通过2和3的数据帧</span><br><span class="line">[h3c-Ethernet 1/0/1]undo port trnk permit vlan 2 to 3</span><br></pre></td></tr></table></figure><h4 id="将Hybrid端口加入到指定的已存在的VLAN，并标记为tagged或untagged"><a href="#将Hybrid端口加入到指定的已存在的VLAN，并标记为tagged或untagged" class="headerlink" title="将Hybrid端口加入到指定的已存在的VLAN，并标记为tagged或untagged"></a>将Hybrid端口加入到指定的已存在的VLAN，并标记为tagged或untagged</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[h3c-Ethernet 1/0/1]port hybrid vlan 30 40 untagged</span><br></pre></td></tr></table></figure><h3 id="配置VLAN-IP"><a href="#配置VLAN-IP" class="headerlink" title="配置VLAN IP"></a>配置VLAN IP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[H3C]inter vlan 2 // 进入interface vlan 2</span><br><span class="line">[H3C-Vlan-interface3] ip addr 40.1.1.1 24 // 配置VLAN2的ip</span><br></pre></td></tr></table></figure><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[R1-Serial1/0]link-protocol ppp // 配置PPP</span><br><span class="line">&lt;R1&gt;debugging ppp all // 打开PPP的debug开关</span><br><span class="line">&lt;R1&gt;terminal debugging // 显示debug信息</span><br><span class="line"></span><br><span class="line">[R1-Serial 1/0]shutdown // 关闭接口</span><br><span class="line">[R1-Serial 1/0]undo shutdown // 启用接口</span><br></pre></td></tr></table></figure><h3 id="PAP验证"><a href="#PAP验证" class="headerlink" title="PAP验证"></a>PAP验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// R1 主验证方</span><br><span class="line">[R1]local-user RTB class network // 配置用户</span><br><span class="line">[R1-local-network-RTB]service-type ppp // 配置服务类型</span><br><span class="line">[R1-local-network-RTB]password simple aaa // 配置用户密码</span><br><span class="line">[R1]interface Serial 1/0</span><br><span class="line">[R1-Serial1/0]ppp authentication pap // 授权PAP验证</span><br><span class="line">// R2 被验证方</span><br><span class="line">[R2]interface Serial 1/0</span><br><span class="line">[R2-Serial 1/0]ppp pap local-user RTB password simple aaa // 配置PAP用户名和视图</span><br><span class="line"></span><br><span class="line">&lt;R1&gt;debugging ppp pap all</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure><h3 id="CHAP验证"><a href="#CHAP验证" class="headerlink" title="CHAP验证"></a>CHAP验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[R1]local-user RTB class network // 配置用户列表</span><br><span class="line">[R1-luser-network-RTB]service-type ppp // 配置服务类型</span><br><span class="line">[R1-luser-network-RTB]pasword simple aaa // 配置用户对应的密码</span><br><span class="line">[R1]Serial 1/0</span><br><span class="line">[R1-Serial 1/0]ppp authentication-mode chap // 授权CHAP验证</span><br><span class="line">[R1-Serial 1/0]ppp chap user RTA // 配置本地名称</span><br><span class="line"></span><br><span class="line">[R2]local-user RTA class network // 配置用户列表</span><br><span class="line">[R2-luser-network-RTA]service-type ppp //配置服务类型</span><br><span class="line">[R2-luser-network-RTA]password simple aaa // 配置用户对应的密码</span><br><span class="line">[R2]interface Serial 1/0</span><br><span class="line">[R2-Serial 1/0]ppp chap user RTB // 配置本地名称</span><br><span class="line"></span><br><span class="line">&lt;R1&gt;debugging ppp chap all</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure><h2 id="Part-3-网络层实验"><a href="#Part-3-网络层实验" class="headerlink" title="Part 3 网络层实验"></a>Part 3 网络层实验</h2><h3 id="配置VLAN的IP和掩码"><a href="#配置VLAN的IP和掩码" class="headerlink" title="配置VLAN的IP和掩码"></a>配置VLAN的IP和掩码</h3><p><img src="image-20230515103429010.png" alt="image-20230515103429010"></p><p>似乎只有明确标注的时候需要配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[S1]vlan 2</span><br><span class="line">[S1]port e 1/0/1</span><br><span class="line">[S1]inter vlan 2</span><br><span class="line">[S1-Vlan-interface]ip add 192.168.1.10 24</span><br></pre></td></tr></table></figure><blockquote><p>注意，上图需要配置PCA和PCB的默认网关分别位VLAN的ip</p></blockquote><h3 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[H3C]display ip routing-table</span><br></pre></td></tr></table></figure><h2 id="Part-4-OSPF协议"><a href="#Part-4-OSPF协议" class="headerlink" title="Part 4 OSPF协议"></a>Part 4 OSPF协议</h2><h3 id="配置Router-ID"><a href="#配置Router-ID" class="headerlink" title="配置Router ID"></a>配置Router ID</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;H3C&gt;system-view</span><br><span class="line">[H3C]router id 1.1.1.1 // 配置路由器的router id为1.1.1.1</span><br><span class="line">[H3C]undo router id</span><br></pre></td></tr></table></figure><h3 id="启动OSPF"><a href="#启动OSPF" class="headerlink" title="启动OSPF"></a>启动OSPF</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[R1]ospf // 启动ospf协议</span><br><span class="line">[R1]undo ospf // 关闭ospf协议</span><br><span class="line">[R1-ospf-1]area 0 // 创建area 0区域视图</span><br><span class="line">[R1-ospf-1]undo area 0 // 删除area0</span><br><span class="line">[R1-ospf-1]network 1.1.1.0 0.0.0.255 // 指定网段运行OSPF协议</span><br></pre></td></tr></table></figure><h3 id="显示OSPF调试信息"><a href="#显示OSPF调试信息" class="headerlink" title="显示OSPF调试信息"></a>显示OSPF调试信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt;debugging ospf event</span><br><span class="line">&lt;R1&gt;dterminal debugging</span><br></pre></td></tr></table></figure><h3 id="配置回环地址（LoopBack）"><a href="#配置回环地址（LoopBack）" class="headerlink" title="配置回环地址（LoopBack）"></a>配置回环地址（LoopBack）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c]inter loop 1 // 进入loopback1</span><br><span class="line">[h3c-LoopBack1]ip addr 4.4.4.4 32 // 配置ip为4.4.4.4/32</span><br></pre></td></tr></table></figure><h3 id="配置串口（Serial）"><a href="#配置串口（Serial）" class="headerlink" title="配置串口（Serial）"></a>配置串口（Serial）</h3><p>路由器间不能使用以太网口直连，需要使用串口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]interface e 0/0 // 进入串口0/0</span><br><span class="line">[R1-Serial 0/0]ip addr 192.168.1.1 24</span><br></pre></td></tr></table></figure><h3 id="配置OSPF-Cost"><a href="#配置OSPF-Cost" class="headerlink" title="配置OSPF Cost"></a>配置OSPF Cost</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 为VLAN配置ospf cost</span><br><span class="line">[R1]inter vlan 3</span><br><span class="line">[R1-Vlan-Interface3]ospf cost 100 /// 配置ospf cost</span><br><span class="line">// 为端口配置ospf cost</span><br><span class="line">[R1]inter g 0/0</span><br><span class="line">[R1-G..0/0]ospf cost 100 // 配置ospf cost</span><br><span class="line">// 为串口配置ospf cost</span><br><span class="line">[R1]inter s 0/0 // 进入串口</span><br><span class="line">[R1-Serial0/0]ospf cost 200 // 配置ospf cost</span><br></pre></td></tr></table></figure><h3 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h3><p>静态路由是由网络管理员手动配置的路由，制定了到达目的网络的出口接口、网络掩码和下一跳地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[H3C]ip route-static 129.1.0.0 255.255.0.0 129.0.0.2 // 配置静态路由，目的网络的IP地址是129.1.0.0，目的网络的子网掩码是255.255.0.0，下一跳路由器的IP地址是129.0.0.2</span><br></pre></td></tr></table></figure><h3 id="配置缺省路由"><a href="#配置缺省路由" class="headerlink" title="配置缺省路由"></a>配置缺省路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[H3C]ip route-static 0.0.0.0 0.0.0.0 129.0.0.1 // 配置缺省路由器为129.0.0.1，和计算机网关的作用类似</span><br></pre></td></tr></table></figure><h3 id="查看OSPF-LSDB"><a href="#查看OSPF-LSDB" class="headerlink" title="查看OSPF LSDB"></a>查看OSPF LSDB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf lsdb router</span><br></pre></td></tr></table></figure><h3 id="排查故障指令"><a href="#排查故障指令" class="headerlink" title="排查故障指令"></a>排查故障指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf peer // 查看邻居路由器状态</span><br><span class="line">[R1]reset ospf all // 重启ospf协议</span><br></pre></td></tr></table></figure><h3 id="路由引入"><a href="#路由引入" class="headerlink" title="路由引入"></a>路由引入</h3><p>将静态路由或直连路由导入到动态路由协议中，使得其他路由器可以通过动态路由协议学习到这些路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[S1-ospf]import-route direct // 引入直连路由</span><br><span class="line">[R1]ip route 192.168.5.0 255.255.255.0 192.168.3.2 // 配置静态路由</span><br><span class="line">[R1-ospf]import-route static // 引入静态路由</span><br></pre></td></tr></table></figure><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>tracert命令可以追踪经过的路由器路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -d 10.35.3.1 // PC可以使用-d，但是路由器和交换机似乎不支持</span><br></pre></td></tr></table></figure><p>网络设备默认不回应tracert命令，因此需要手动开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[S1]ip ttl-expires enable</span><br><span class="line">[S1]ip unreachables enable</span><br></pre></td></tr></table></figure><h2 id="Part-5-BGP实验"><a href="#Part-5-BGP实验" class="headerlink" title="Part 5 BGP实验"></a>Part 5 BGP实验</h2><h3 id="启动BGP"><a href="#启动BGP" class="headerlink" title="启动BGP"></a>启动BGP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]bgp 100 // 在R1上启动BGP协议，AS号为100</span><br></pre></td></tr></table></figure><h3 id="加入邻居"><a href="#加入邻居" class="headerlink" title="加入邻居"></a>加入邻居</h3><p><img src="image-20230516170629621.png" alt="image-20230516170629621"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[S1-bgp]peer 1.1.1.2 as-number 300 // 1.1.1.2是在AS300中和R1相连的IP(?看图说话属于是)</span><br><span class="line">[S1-bgp]peer 3.1.1.2 as-number 300 // AS内部邻居</span><br><span class="line">[S1-bgp]address-family ipv4 unicast // 设置地址簇为IPv4</span><br><span class="line">[S1-bgp-ipv4]peer 3.1.1.2 enable // 在IPv4视图中使能邻居设置</span><br></pre></td></tr></table></figure><h3 id="强制下一跳为本身接口（next-hop-local）"><a href="#强制下一跳为本身接口（next-hop-local）" class="headerlink" title="强制下一跳为本身接口（next-hop-local）"></a>强制下一跳为本身接口（next-hop-local）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[S1-bgp]peer 3.1.1.2 next-hop-local // 强制下一跳为本身接口</span><br></pre></td></tr></table></figure><blockquote><p>笔者认为，这是由于S1和S2是IBGP。举例而言，S1向S2广播路由的时候，需要让S2将新学习到的路由的下一跳设为S1，这样IBGP邻居（S2）就可以访问从EBGP邻居学习到的路由了</p></blockquote><p><img src="image-20230516171625928.png" alt="image-20230516171625928"></p><h3 id="查看BGP路由表"><a href="#查看BGP路由表" class="headerlink" title="查看BGP路由表"></a>查看BGP路由表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1-bgp]display bgp routing-table // 查看BGP路由表</span><br></pre></td></tr></table></figure><h3 id="查看BGP邻居状态"><a href="#查看BGP邻居状态" class="headerlink" title="查看BGP邻居状态"></a>查看BGP邻居状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]display bgp peer</span><br></pre></td></tr></table></figure><h3 id="向BGP注入路由信息"><a href="#向BGP注入路由信息" class="headerlink" title="向BGP注入路由信息"></a>向BGP注入路由信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]bgp 100 // 进入BGP视图</span><br><span class="line">[R1-bgp]network 5.5.5.5 255.255.255.255 // 注入5.5.5.5/32网段的路由信息</span><br></pre></td></tr></table></figure><h3 id="ping-a"><a href="#ping-a" class="headerlink" title="ping-a"></a><code>ping-a</code></h3><p>可以指定用哪个IP去ping。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]ping -a 5.5.5.5 4.4.4.4 // 以5.5.5.5作为源地址ping 4.4.4.4；如果不用-a参数，那么就会用别的IP去ping，而别的ip没有注入路由，因此会无法ping通</span><br></pre></td></tr></table></figure><h3 id="debug信息"><a href="#debug信息" class="headerlink" title="debug信息"></a>debug信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt;debug bgp event</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure><h3 id="路由引入-1"><a href="#路由引入-1" class="headerlink" title="路由引入"></a>路由引入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1-bgp]import-route direct // 引入直连路由</span><br></pre></td></tr></table></figure><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><h4 id="基于ACL的路由过滤"><a href="#基于ACL的路由过滤" class="headerlink" title="基于ACL的路由过滤"></a>基于ACL的路由过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[R2]acl number 2001</span><br><span class="line">[R2-acl-basic-2001]rule 0 deny source 5.0.0.0 0.255.255.255 </span><br><span class="line">[R2-acl-basic-2001]rule 1 permit source 0.0.0.0 255.255.255.255</span><br><span class="line">[S2]bgp 300</span><br><span class="line">[S2-bgp]peer 2.1.1.2 filter-policy 2001 export // 配置基于ACL的路由过滤</span><br></pre></td></tr></table></figure><h4 id="配置基于AS-Path的路由过滤"><a href="#配置基于AS-Path的路由过滤" class="headerlink" title="配置基于AS-Path的路由过滤"></a>配置基于AS-Path的路由过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[S1]ip as-path 1 deny \b200$ // 设置拒绝来自AS200的路由</span><br><span class="line">[S1]ip as-path 1 permit ^$ // 设置允许本AS的路由</span><br><span class="line">[S1]bgp 300</span><br><span class="line">[S1-bgp]peer 1.1.1.1 as-path-acl 1 export // 配置基于AS-Path的路由过滤</span><br></pre></td></tr></table></figure><h4 id="配置基于Route-Policy的路由过滤"><a href="#配置基于Route-Policy的路由过滤" class="headerlink" title="配置基于Route Policy的路由过滤"></a>配置基于Route Policy的路由过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[S1]acl number 2001</span><br><span class="line">[S1-acl-basic-2001]rule 1 deny source 6.0.0.0 0.255.255.255</span><br><span class="line">[S1-acl-basic-2001]rule 2 permit source any</span><br><span class="line">[S1-acl-basic-2001]quit</span><br><span class="line">[S1]route-policy deny6 permit node 10 // 配置route-policy内容</span><br><span class="line">[S1-route-policy]if-match acl 2001</span><br><span class="line">[S1-route-policy]apply cost 888</span><br><span class="line">[S1-route-policy]quit</span><br></pre></td></tr></table></figure><h2 id="Part-6-应用层实验"><a href="#Part-6-应用层实验" class="headerlink" title="Part 6 应用层实验"></a>Part 6 应用层实验</h2><h2 id="Part-7-传输层实验"><a href="#Part-7-传输层实验" class="headerlink" title="Part 7 传输层实验"></a>Part 7 传输层实验</h2><h2 id="Part-8-复杂组网实验"><a href="#Part-8-复杂组网实验" class="headerlink" title="Part 8 复杂组网实验"></a>Part 8 复杂组网实验</h2><h2 id="Part-9-期末上机备忘"><a href="#Part-9-期末上机备忘" class="headerlink" title="Part 9 期末上机备忘"></a>Part 9 期末上机备忘</h2><h3 id="Step-1-通读试卷，连线组网"><a href="#Step-1-通读试卷，连线组网" class="headerlink" title="Step -1 通读试卷，连线组网"></a>Step -1 通读试卷，连线组网</h3><p>需要注意，真正组网的图不一定完全和试卷上的相同。如，当试卷后面某个简答题要求抓获某两个网络设备间的报文时，需要在其中配一个HUB，并连接一台PC以抓取报文。</p><h3 id="Step-0-禁用虚拟网卡"><a href="#Step-0-禁用虚拟网卡" class="headerlink" title="Step 0 禁用虚拟网卡"></a>Step 0 禁用虚拟网卡</h3><p>开机后对于TCP实验（需要用到Linux系统），就要禁用虚拟网卡。由于一旦操作了网络设备就需要重启才能禁用虚拟网卡，所以这一步要最开始做。</p><h3 id="Step-1-清空并重启网络设备"><a href="#Step-1-清空并重启网络设备" class="headerlink" title="Step 1 清空并重启网络设备"></a>Step 1 清空并重启网络设备</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;H3C&gt;reset saved configuration // y</span><br><span class="line">[H3C]reboot // 先n后y</span><br></pre></td></tr></table></figure><h3 id="Step-2-取消vlan-1接口的ip-addr"><a href="#Step-2-取消vlan-1接口的ip-addr" class="headerlink" title="Step 2 取消vlan 1接口的ip addr"></a>Step 2 取消vlan 1接口的ip addr</h3><p>网络设备默认<code>interface vlan 1</code>配置了<code>192.168.1.1</code>的IP地址，因此需要<code>undo</code>该地址避免冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[H3C]interface vlan 1</span><br><span class="line">[H3C-vlan-1]undo ip addr</span><br></pre></td></tr></table></figure><h3 id="Step-3-优先配置PC的IP"><a href="#Step-3-优先配置PC的IP" class="headerlink" title="Step 3 优先配置PC的IP"></a>Step 3 优先配置PC的IP</h3><p>首先配置PC的IP，注意IP,子网掩码和默认网关。配好后可以ping一下自己确定没有手误。</p><h3 id="Step-4-配置网络设备的端口、IP和VLAN"><a href="#Step-4-配置网络设备的端口、IP和VLAN" class="headerlink" title="Step 4 配置网络设备的端口、IP和VLAN"></a>Step 4 配置网络设备的端口、IP和VLAN</h3><p>笔者建议先配置这些内容，OSPF/BGP等下一步再配置。另外，可以一边配置一边ping自己或直连IP，确认没有错误。</p><h3 id="Step-5-配置-OSPF-BGP-NAT"><a href="#Step-5-配置-OSPF-BGP-NAT" class="headerlink" title="Step 5 配置 OSPF/BGP/NAT"></a>Step 5 配置 OSPF/BGP/NAT</h3><p>配置时，可以善用<code>display</code>等命令查看路由表、BGP邻居状态等，也可以随时ping自己IP和判断能ping通的ip，没问题再进行下一步。</p><h3 id="Step-6-配置静态路由-路由引入"><a href="#Step-6-配置静态路由-路由引入" class="headerlink" title="Step 6 配置静态路由/路由引入"></a>Step 6 配置静态路由/路由引入</h3><p>当不能达到题目要求（如全网连通/PCB ping PCC）时，一点一点分析哪里有问题，并配置静态路由或引入路由（静态/直连）。需要注意题目是否允许配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「BUAA-Computer-Network-Experiment」Notes&quot;&gt;&lt;a href=&quot;#「BUAA-Computer-Network-Experiment」Notes&quot; class=&quot;headerlink&quot; title=&quot;「BUAA Computer</summary>
      
    
    
    
    
    <category term="BUAA Computer Network Experiment" scheme="https://saltyfishyjk.github.io/tags/BUAA-Computer-Network-Experiment/"/>
    
  </entry>
  
  <entry>
    <title>Notion笔记</title>
    <link href="https://saltyfishyjk.github.io/2023/04/22/Notion%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/04/22/Notion%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-22T11:03:22.000Z</published>
    <updated>2024-01-27T12:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notion笔记"><a href="#Notion笔记" class="headerlink" title="Notion笔记"></a>Notion笔记</h1><h1 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h1><p>Notion是一款不错的笔记和团队协作软件，笔者主要在罗杰软工期间接触和使用。由于Notion自身拥有一套完整的哲学和使用方法，特别是和经典的markdown编辑器如Typora的使用方法存在诸多细小的差异，因此在这里记录。</p><h2 id="Part-1-快捷键"><a href="#Part-1-快捷键" class="headerlink" title="Part 1 快捷键"></a>Part 1 快捷键</h2><h3 id="ctrl-k-网页链接"><a href="#ctrl-k-网页链接" class="headerlink" title="ctrl + k 网页链接"></a><code>ctrl + k</code> 网页链接</h3><p>选中文本后<code>ctrl + k</code>并填入网址可以制作超链接。</p><h2 id="Part-2-Button"><a href="#Part-2-Button" class="headerlink" title="Part 2 Button"></a>Part 2 Button</h2><h2 id="Part-3-bug-与踩坑"><a href="#Part-3-bug-与踩坑" class="headerlink" title="Part 3 bug 与踩坑"></a>Part 3 bug 与踩坑</h2><h3 id="输入中文时，输入法焦点总是在屏幕左上角"><a href="#输入中文时，输入法焦点总是在屏幕左上角" class="headerlink" title="输入中文时，输入法焦点总是在屏幕左上角"></a>输入中文时，输入法焦点总是在屏幕左上角</h3><p>解决方案：在开始菜单栏中打一个字，再切回即可</p><p>参考：<a href="https://github.com/Reamd7/notion-zh_CN/issues/17">输入中文时，输入法焦点总是在左上角 </a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Notion笔记&quot;&gt;&lt;a href=&quot;#Notion笔记&quot; class=&quot;headerlink&quot; title=&quot;Notion笔记&quot;&gt;&lt;/a&gt;Notion笔记&lt;/h1&gt;&lt;h1 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions笔记</title>
    <link href="https://saltyfishyjk.github.io/2023/04/20/GitHub-Actions%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/04/20/GitHub-Actions%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-20T01:59:26.000Z</published>
    <updated>2023-04-20T03:25:40.000Z</updated>
    
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
    <category term="Server" scheme="https://saltyfishyjk.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>Nginx笔记</title>
    <link href="https://saltyfishyjk.github.io/2023/04/20/Nginx%E7%AC%94%E8%AE%B0/"/>
    <id>https://saltyfishyjk.github.io/2023/04/20/Nginx%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-20T01:57:39.000Z</published>
    <updated>2023-04-20T12:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx笔记"><a href="#Nginx笔记" class="headerlink" title="Nginx笔记"></a>Nginx笔记</h1><h2 id="Part-0-前言"><a href="#Part-0-前言" class="headerlink" title="Part 0 前言"></a>Part 0 前言</h2><p>参考资料：</p><ul><li><a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx 配置详解 - runoob</a></li><li><a href="https://www.hxstrive.com/subject/nginx/750.htm">Nginx 教程 - 人人编程网</a></li></ul><p>Nginx音标为<code>/&#39;endʒɪneks/</code>，读音为<code>engine x</code>。</p><p>Nginx适合承担HTTP服务器和反向代理服务器的工作，也可以提供方便的静态资源配置与访问。</p><p>同时，Docker提供了不错的对Nginx的封装，很适合将其加入CI/CD工作流。</p><h2 id="Part-1-安装"><a href="#Part-1-安装" class="headerlink" title="Part 1 安装"></a>Part 1 安装</h2><blockquote><p>环境：Ubuntu 20.04</p></blockquote><p>Ubuntu下安装Nginx的难度不大，没有什么坑。</p><ul><li><code>sudo apt-get install nginx</code></li></ul><p><em>TODO:忘记记录怎么启动起来的nginx服务了，好像执行过<code>sudo nginx -t</code>和<code>sudo nginx -s reload</code></em></p><h2 id="Part-2-配置文件nginx-conf结构"><a href="#Part-2-配置文件nginx-conf结构" class="headerlink" title="Part 2 配置文件nginx.conf结构"></a>Part 2 配置文件<code>nginx.conf</code>结构</h2><p>参考资料：</p><ul><li><p><a href="http://nginx.org/en/docs/">Nginx官方英文文档</a>：纯英文，是最准确的资料</p></li><li><p><a href="https://docshome.gitbook.io/">Nginx中文文档（GitBook , 私人笔记）</a>：一个个人GitBook笔记网站，是对上面官方文档的翻译，但是<strong>注意，并非所有翻译都很恰当，应当两者结合阅读</strong>。</p></li><li><a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx配置文件 - runoob</a></li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Nginx的命令行参数不多，配置文件<code>nginx.conf</code>是Nginx服务的核心，这决定了Nginx和其模块的工作方式。</p><p>默认情况下，<code>nginx.conf</code>放在<code>/usr/local/nginx/conf</code>，<code>/etc/nginx</code> 或 <code>/usr/local/etc/nginx</code> 中。因此，当利用Docker构建CI/CD时，需要注意将仓库中的<code>nginx.conf</code>文件移动到容器的合适位置。具体地，笔者曾在Dockerfile中用过<code>COPY nginx.conf /etc/nginx/nginx.conf</code>。</p><blockquote><p>VSCode提供了<code>NGINX Conf</code>插件，适合用来高亮文本和格式化文档。</p></blockquote><h3 id="nginx组成"><a href="#nginx组成" class="headerlink" title="nginx组成"></a>nginx组成</h3><p>nginx由模块（module）组成，模块由配置文件（nginx.conf）中的指令（directives）控制。指令又分为简单指令（simple directive）和块指令（block directive）。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li><p>简单指令</p><ul><li>结构：名称和参数组成，由空格分隔，以<code>;</code>结尾</li><li>形如：<code>[名称] [参数];</code></li></ul></li><li><p>块指令</p><ul><li>结构：和简单指令相同，但不以<code>;</code>结尾，而是以一组由<code>&#123;&#125;</code>包围的附加指令结尾。</li><li>形如：<code>[名称] [参数] &#123;若干附加指令&#125;</code></li></ul></li></ul><p>如果块指令的<code>&#123;&#125;</code>中可以包含其他指令，那么它被称为上下文（context）。</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上下文包括：</p><ul><li><code>events</code></li><li><code>http</code></li><li><code>server</code></li><li><code>location</code></li></ul><p>配置文件中在所有上下文之外的指令被认为是在主（main）上下文中。比如，<code>events</code>和<code>http</code>在<code>main</code>上下文中；<code>server</code>在<code>http</code>上下文中；<code>location</code>在<code>server</code>上下文中。因此可以形如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx; <span class="comment"># 简单指令，在main中</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>; <span class="comment"># 简单指令，在main中</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>; <span class="comment"># 简单指令，在events中</span></span><br><span class="line">&#125; <span class="comment"># 块指令，在main中</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 简单指令，在server中</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /app; <span class="comment"># 简单指令，在location中</span></span><br><span class="line">        &#125; <span class="comment"># 块指令，在server中</span></span><br><span class="line">    &#125; <span class="comment"># 块指令，在http中</span></span><br><span class="line">&#125; <span class="comment"># 块指令，在main中</span></span><br></pre></td></tr></table></figure><h2 id="Part-3-main-context"><a href="#Part-3-main-context" class="headerlink" title="Part 3 main context"></a>Part 3 <code>main</code> context</h2><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/Leon_Jinhai_Sun/article/details/121044983">Nginx全局块的user指令</a></li></ul><p><code>main</code> 上下文是默认上下文，不显示声明，任何不隶属于任意其他上下文的指令均被认为是在<code>main</code>上下文中。</p><p>e.g.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx; <span class="comment"># 配置用户或用户组，格式为user user [group]默认为user nobody nobody，用于精确管理权限</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>; <span class="comment"># 允许生成的进程数，默认为1</span></span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid <span class="comment"># 指定nginx进程运行文件的存放地址</span></span><br><span class="line">error_log /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>; <span class="comment"># 指定日志路径和级别，本设置可以放入main, http, server；级别包括debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="section">events</span> &#123; <span class="comment"># events块，在后续介绍</span></span><br><span class="line">    <span class="comment"># codes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123; <span class="comment"># http块，在后续介绍</span></span><br><span class="line">    <span class="comment"># codes</span></span><br><span class="line">    <span class="section">server</span> &#123; <span class="comment"># server块，在后续介绍</span></span><br><span class="line">        <span class="comment"># codes</span></span><br><span class="line">        <span class="section">location</span> &#123; <span class="comment"># location块，在后续介绍</span></span><br><span class="line">            <span class="comment"># codes</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> &#123;</span><br><span class="line">            <span class="comment"># codes</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># codes</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-4-events-context"><a href="#Part-4-events-context" class="headerlink" title="Part 4 events context"></a>Part 4 <code>events</code> context</h2><p>参考资料：</p><ul><li><a href="https://www.hxstrive.com/subject/nginx/805.htm">events 配置块介绍 - 人人编程网</a></li></ul><p><code>events</code>模块包含了Nginx中处理连接的设置。</p><p>e.g.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>; <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>; <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>; <span class="comment"># 最大连接数，默认为512</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line">    <span class="attribute">open_file_cache</span> max=<span class="number">2000</span> inactive=<span class="number">60s</span>;</span><br><span class="line">    <span class="attribute">open_file_cache_valid</span> <span class="number">60s</span>;</span><br><span class="line">    <span class="attribute">open_file_cache_min_uses</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用设置是<code>worker_connections</code>，其余配置没有特殊需求可以保持默认，即，不添加描述字段。</p><h2 id="Part-5-http-context"><a href="#Part-5-http-context" class="headerlink" title="Part 5 http context"></a>Part 5 <code>http</code> context</h2><p>参考资料：</p><ul><li><a href="https://www.hxstrive.com/subject/nginx/806.htm">http配置块介绍 - 人人编程网</a></li></ul><p>e.g.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types; <span class="comment"># 文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream; <span class="comment"># 默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># codes</span></span><br><span class="line">        <span class="section">location</span> &#123;</span><br><span class="line">            <span class="comment"># codes</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> &#123;</span><br><span class="line">            <span class="comment"># codes</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># codes</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h3><p>将文件扩展名与文件类型映射表包含或另一个文件到当前配置中。<code>mine.types</code>形如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">types</span> &#123;</span><br><span class="line">    text/<span class="attribute">html</span>                                        html htm shtml;</span><br><span class="line">    text/<span class="attribute">css</span>                                         css;</span><br><span class="line">    text/<span class="attribute">xml</span>                                         xml;</span><br><span class="line">    image/<span class="attribute">gif</span>                                        gif;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>include</code>引入其他的<code>server</code>配置文件。</p><h3 id="default-type"><a href="#default-type" class="headerlink" title="default_type"></a><code>default_type</code></h3><p>设置默认处理方式。</p><h3 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a><code>keepalive_timeout</code></h3><p>设置web服务器处理完一个请求后保持这个TCP连接的时间，Nginx默认为75秒。</p><h2 id="Part-6-server"><a href="#Part-6-server" class="headerlink" title="Part 6 server"></a>Part 6 <code>server</code></h2><p>参考资料：</p><ul><li><a href="https://www.hxstrive.com/subject/nginx/807.htm">server 配置块介绍 - 人人编程网</a></li></ul><p>在Nginx中，一个server配置块代表了一个虚拟机主机。</p><p>虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成多台 “虚拟” 的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，具有完整的 Internet 服务器功能（WWW、FTP、Email 等等），同一台主机上的虚拟主机之间是完全独立的。</p><p>从网站访问者来看，每一台虚拟主机和一台独立主机完全一样。</p><p>利用虚拟主机，不用为每个要运行的网站提供一台单独的 Nginx 服务器或单独运行一组 Nginx 进程。虚拟主机提供了在同一台服务器、同一组 Nginx 进程上运行多个网站的功能。</p><p>e.g.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># codes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="comment"># codes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /prod-api &#123;</span><br><span class="line">        <span class="comment"># codes</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a><code>listen</code></h3><p>Nginx通过<code>listen</code>指令指定的值监听网络请求，可以是IP协议，也可以是UNIX域套接字。若不设置<code>listen</code>指令，Nginx以超级用户运行时监听80端口，非超级用户运行时监听8000端口。</p><p><code>listen</code>指令的值提供了丰富的参数，具体可以参考<a href="https://www.hxstrive.com/subject/nginx/807.htm">server 配置块介绍 - 人人编程网</a>。</p><h3 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a><code>server_name</code></h3><p><code>server_name</code>指令主要用于配置基于名称的虚拟主机，在接收到客户请求后的匹配顺序为准确的<code>server_name</code>匹配 &gt; 以<code>*</code>通配符开始发字符串 &gt; 以<code>*</code>通配符结束的字符串 &gt; 正则表达式，具体可以参考<a href="https://www.hxstrive.com/subject/nginx/807.htm">server 配置块介绍 - 人人编程网</a>。</p><h3 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a><code>access_log</code></h3><p>用于指定日志文件的存放路径和格式。</p><h2 id="Part-7-location"><a href="#Part-7-location" class="headerlink" title="Part 7 location"></a>Part 7 <code>location</code></h2><p>参考资料：</p><ul><li><a href="https://www.hxstrive.com/subject/nginx/808.htm">location 配置块介绍 - 人人编程网</a></li></ul><p><code>location</code>配置块用来配置匹配的不同请求URL的处理方式。<code>location</code>块只能在<code>server</code>块中配置。</p><p>e.g.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /app;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /prod-api &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/prod-api/(.*)$</span> /<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://101.43.219.110:8080/; <span class="comment">#后台接口地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="location"><a href="#location" class="headerlink" title="location"></a><code>location</code></h3><ul><li><p>格式</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> [ = | <span class="regexp">~ |</span> <span class="regexp">~* |</span><span class="regexp"> ^~</span> ] /URL &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数说明</p><ul><li>空：表示前缀匹配，代表跟请求中的URL从头开始匹配。</li><li><code>=</code>：用于标准URL前，要求精确匹配，成功则立即处理，Nginx停止搜索其他匹配。</li><li><code>^~</code>：用于标准URL前，要求一旦匹配就会立即处理，不在匹配其他正则URL，一般用来匹配目录</li><li><code>~</code>：用于正则URL前，表示URL包含正则表达式，区分大小写</li><li><code>~*</code>：用于正则URL前，表示URL包含正则表达式，不区分大小写</li></ul></li></ul><h3 id="命名location"><a href="#命名location" class="headerlink" title="命名location"></a>命名<code>location</code></h3><p>暂时没有用过，可以参考<a href="https://www.hxstrive.com/subject/nginx/808.htm">location 配置块介绍 - 人人编程网</a></p><h3 id="URL匹配顺序"><a href="#URL匹配顺序" class="headerlink" title="URL匹配顺序"></a>URL匹配顺序</h3><p>可以参考<a href="https://www.hxstrive.com/subject/nginx/808.htm">location 配置块介绍 - 人人编程网</a></p><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a><code>proxy_pass</code></h3><p>用来设置代理服务器的映射地址，可以使用http或https协议，地址可以使用域名、IP和可选端口。</p><h2 id="Part-8-图床与静态资源"><a href="#Part-8-图床与静态资源" class="headerlink" title="Part 8 图床与静态资源"></a>Part 8 图床与静态资源</h2><h2 id="Part-9-Vue项目打包与部署"><a href="#Part-9-Vue项目打包与部署" class="headerlink" title="Part 9 Vue项目打包与部署"></a>Part 9 Vue项目打包与部署</h2><h2 id="Part-10-Docker部署"><a href="#Part-10-Docker部署" class="headerlink" title="Part 10 Docker部署"></a>Part 10 Docker部署</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx笔记&quot;&gt;&lt;a href=&quot;#Nginx笔记&quot; class=&quot;headerlink&quot; title=&quot;Nginx笔记&quot;&gt;&lt;/a&gt;Nginx笔记&lt;/h1&gt;&lt;h2 id=&quot;Part-0-前言&quot;&gt;&lt;a href=&quot;#Part-0-前言&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://saltyfishyjk.github.io/tags/Tools/"/>
    
    <category term="Server" scheme="https://saltyfishyjk.github.io/tags/Server/"/>
    
  </entry>
  
</feed>
