<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="saltyfishyjk, yjk, @saltyfishyjk, @yjk, saltyfishyjk&#39;s Blog">
    <link rel="shortcut icon" href="/img/x.ico">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          「BUAA OS Lab5」名词解释 - saltyfishyjk
        
    </title>

    <link rel="canonical" href="https://saltyfishyjk.github.io/2022/05/31/「BUAA-OS-Lab5」名词解释/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="saltyfishyjk's Blog" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('../../../../img/default.jpg')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#BUAA-OS" title="BUAA-OS">BUAA-OS</a>
                            
                        </div>
                        <h1>「BUAA OS Lab5」名词解释</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by saltyfishyjk on
                            2022-05-31
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">5.9k</span> and
                                Reading Time <span class="post-count">29</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">saltyfishyjk&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                    <li>
                        <a href="https://home.cnblogs.com/u/saltyfishyjk" target="_blank">Chinese Blog</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="「BUAA-OS-Lab5」名词解释"><a href="#「BUAA-OS-Lab5」名词解释" class="headerlink" title="「BUAA OS Lab5」名词解释"></a>「BUAA OS Lab5」名词解释</h1><h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a><code>Block</code></h3><p>磁盘块，虚拟概念，将相邻的扇区组合在一起，减小由于扇区过多带来的寻址困难。</p>
<p>磁盘块控制块</p>
<p>位置：<code>fs/fsformat.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line">    <span class="type">uint32_t</span> type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>uint8_t</code>是<code>unsigned char</code>，<code>uint32_t</code>是<code>unsigned</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BLOCK_FREE = <span class="number">0</span>,</span><br><span class="line">    BLOCK_BOOT = <span class="number">1</span>,</span><br><span class="line">    BLOCK_BMAP = <span class="number">2</span>,</span><br><span class="line">    BLOCK_SUPER = <span class="number">3</span>,</span><br><span class="line">    BLOCK_DATA = <span class="number">4</span>,</span><br><span class="line">    BLOCK_FILE = <span class="number">5</span>,</span><br><span class="line">    BLOCK_INDEX = <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可能的类型以枚举类的形式给出。</p>
<p>&#x2F;&#x2F; Parameters:<br>&#x2F;&#x2F;  diskno: disk number.<br>&#x2F;&#x2F;  secno: start sector number.<br>&#x2F;&#x2F;  dst: destination for data read from IDE disk.<br>&#x2F;&#x2F;  nsecs: the number of sectors to read.</p>
<hr>
<h3 id="disk"><a href="#disk" class="headerlink" title="disk"></a><code>disk</code></h3><p>位置：<code>fs/fsformat.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line">    <span class="type">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];</span><br></pre></td></tr></table></figure>

<p>磁盘块控制块对象，保存了<code>NBLOCK</code>个<code>Block</code>对象，与磁盘块一一对应，方便我们通过<code>disk</code>加上<code>offset</code>快速找到物理磁盘块对应的控制块数据结构。</p>
<ul>
<li><code>data</code>：用来索引具体的字节</li>
<li><code>type</code>：这个磁盘块所属类型</li>
</ul>
<p>值得注意的是，为了便于计算，我们不使用间接磁盘块的前10个指针。举例而言：对于一个给定的<code>File</code>结构体，我们通过<code>f_size/BY2BLK</code>计算得到该文件占用磁盘块数<code>i</code>后，如果<code>i &gt; NDIRECT</code>，即，不止使用了直接磁盘块，这时我们要索引<code>j &gt;= NDIRECT</code>的磁盘块的时候就需要先索引<code>f_indirect</code>，得到间接磁盘块的管理块号，通过<code>disk</code>加上<code>f_indirect</code>索引到具体的这个磁盘块的控制块。接着，我们直接用<code>data+j</code>的定位方式检索到对应的磁盘块号。注意，这里检索用的偏移是<code>j</code>，而不是<code>j - NDIRECT</code>，因此，我们简化了计算。稍微多思考一下我们会发现，这里的操作印证了为什么一个文件的最大大小是</p>
<hr>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a><code>Super</code></h3><p>超级块Super Block，用来描述文件系统的基本信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">	u_int s_magic;     <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">	u_int s_nblocks;   <span class="comment">// Total number of blocks on disk </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span> <span class="comment">// Root directory node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s_magic：魔数，用于识别该文件系统，是一个常量</p>
<p>s_nblocks：记录本文件系统有多少个磁盘块，在本文件系统中是1024</p>
<p>s_root：根目录，其<code>f_type</code>为<code>FTYPE_DIR</code>，<code>f_name</code>为<code>/</code></p>
<hr>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a><code>super</code></h3><p>位置：<code>fs/fs.c</code></p>
<p>超级块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> *<span class="title">super</span>;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="nextbno"><a href="#nextbno" class="headerlink" title="nextbno"></a><code>nextbno</code></h3><p>下一个可用的block块号</p>
<p>位置：<code>fs/fsformat.c</code></p>
<hr>
<h3 id="nbitblock"><a href="#nbitblock" class="headerlink" title="nbitblock"></a><code>nbitblock</code></h3><p>标记磁盘所有块的实用信息，其值为1，即，需要一个磁盘块储存位图管理信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或许，你对分子中的BIT2BLK - 1心存疑虑，事实上，其效果为NBLOCK&#x2F;BIT2BLK的答案向上取整</p>
</blockquote>
<hr>
<h3 id="NBLOCK"><a href="#NBLOCK" class="headerlink" title="NBLOCK"></a><code>NBLOCK</code></h3><p>位置：<code>fs/fsformat.c</code></p>
<p>表示文件系统有多少个磁盘块，其值为1024</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBLOCK 1024 <span class="comment">// The number of blocks in the disk.</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="BY2BLK"><a href="#BY2BLK" class="headerlink" title="BY2BLK"></a><code>BY2BLK</code></h3><p>位置：<code>fs.h</code></p>
<p>byte to block ，一块字节数，其值和BY2PG（一页字节数）相同，均为4096</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BY2BLK BY2PG</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="BIT2BLK"><a href="#BIT2BLK" class="headerlink" title="BIT2BLK"></a><code>BIT2BLK</code></h3><p>bit to block，一块位数，其值位<code>BY2BLK</code>的8倍（1 byte &#x3D; 8 bit），32768</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT2BLK (BY2BLK * 8)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FILE2BLK"><a href="#FILE2BLK" class="headerlink" title="FILE2BLK"></a><code>FILE2BLK</code></h3><p>一个block块可以容纳File指针的数量</p>
<p>位置：<code>include/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE2BLK (BY2BLK / sizeof(struct File)</span></span><br></pre></td></tr></table></figure>

<p>简单计算可以知道，该宏值为16，即，一个block块可以储存16个File指针</p>
<hr>
<h3 id="MAXNAMELEN"><a href="#MAXNAMELEN" class="headerlink" title="MAXNAMELEN"></a><code>MAXNAMELEN</code></h3><p>文件名最大长度，其值为128，即，文件名不可以超过128个字符。事实上，由于最后一个字符必须是<code>\0</code>，因此，“有效”字符串最大长度为127.</p>
<p>位置：<code>include/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum size of a filename (a single path component), including null</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN 128</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="MAXPATHLEN"><a href="#MAXPATHLEN" class="headerlink" title="MAXPATHLEN"></a><code>MAXPATHLEN</code></h3><p>位置：<code>include/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPATHLEN 1024</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="NDIRECT"><a href="#NDIRECT" class="headerlink" title="NDIRECT"></a><code>NDIRECT</code></h3><p>文件控制块中直接块指针的数量，其值为10</p>
<p>位置：<code>include/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number of (direct) block pointers in a File descriptor</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 10</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="NINDIRECT"><a href="#NINDIRECT" class="headerlink" title="NINDIRECT"></a><code>NINDIRECT</code></h3><p>文件控制块中间接块指针可以管理的块数量上限</p>
<p>位置：<code>include/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BY2BLK / 4)</span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="FTYPE-REG"><a href="#FTYPE-REG" class="headerlink" title="FTYPE_REG"></a><code>FTYPE_REG</code></h3><p>regular file， 常规文件</p>
<p>位置：<code>include/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_REG 0 <span class="comment">// Regular file</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FTYPE-DIR"><a href="#FTYPE-DIR" class="headerlink" title="FTYPE_DIR"></a><code>FTYPE_DIR</code></h3><p>directory file，文件夹文件</p>
<p>位置：<code>include/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_DIR 1 <span class="comment">// Directory</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FTYPE-BIN"><a href="#FTYPE-BIN" class="headerlink" title="FTYPE_BIN"></a><code>FTYPE_BIN</code></h3><p>binary file，二进制文件</p>
<p>位置：<code>include/fs.h</code></p>
<hr>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a><code>File</code></h3><p>文件控制块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u_char f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line">	u_int f_size;			   <span class="comment">// file size in bytes</span></span><br><span class="line">	u_int f_type;			   <span class="comment">// file type</span></span><br><span class="line">	u_int f_direct[NDIRECT];</span><br><span class="line">	u_int f_indirect;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// valid only in memory</span></span><br><span class="line">	u_char f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">4</span> - <span class="number">4</span> - NDIRECT * <span class="number">4</span> - <span class="number">4</span> - <span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>f_type</code>为文件类型，有普通文件<code>FTYPE_REG</code>和文件夹<code>FTYPE_DIR</code>两种</p>
<p><code>f_direct[NDIRECT]</code>用来记录文件的</p>
<p>数据块在磁盘上的位置，设有十个直接指针，计算可以知道我们的十个直接指针可以表示最大40KB的文件，而当文件大于40KB时，需要用到间接指针。</p>
<p><code>f_indirect</code>是间接指针，指向一个间接磁盘块，用来存储指向文件内容的磁盘块的指针。为了简化计算，我们不使用简介磁盘块的前十个指针。</p>
<p><code>f_dir</code>指向文件所属的文件目录。</p>
<p><code>f_pad</code>是为了使得整个结构体大小是2的幂数，以便于整数个结构体占用一个磁盘块，占用剩下的字节。（利用了<code>char</code>是一个字节的特点）。</p>
<p>对于一个目录型文件，其结构如下：</p>
<hr>
<h3 id="FS-MAGIC"><a href="#FS-MAGIC" class="headerlink" title="FS_MAGIC"></a><code>FS_MAGIC</code></h3><p>位置：<code>include/fs.h</code></p>
<p>魔数，好像是OS课程代码，表示有效性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC 0x68286097 <span class="comment">// Everyone&#x27;s favorite OS class</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DISKMAP"><a href="#DISKMAP" class="headerlink" title="DISKMAP"></a><code>DISKMAP</code></h3><p>位置：<code>fs/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Disk block n, when in memory, is mapped into the file system</span></span><br><span class="line"><span class="comment"> * server&#x27;s address space at DISKMAP+(n*BY2BLK). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAP 0x10000000</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DISKMAX"><a href="#DISKMAX" class="headerlink" title="DISKMAX"></a><code>DISKMAX</code></h3><p>位置：<code>fs/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum disk size we can handle (1GB) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Fd"><a href="#Fd" class="headerlink" title="Fd"></a><code>Fd</code></h3><p>File Descripter，文件描述符</p>
<p>位置：<code>user/fd.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Filefd"><a href="#Filefd" class="headerlink" title="Filefd"></a><code>Filefd</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="MAXFD"><a href="#MAXFD" class="headerlink" title="MAXFD"></a><code>MAXFD</code></h3><p>最大文件控制符数量。我们的MOS能够管理的中最多文件控制符是32个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFD 32</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FILEBASE"><a href="#FILEBASE" class="headerlink" title="FILEBASE"></a><code>FILEBASE</code></h3><p>文件基地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FDTABLE"><a href="#FDTABLE" class="headerlink" title="FDTABLE"></a><code>FDTABLE</code></h3><p>fd基地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FDTABLE (FILEBASE - PDMAP)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FSREQ"><a href="#FSREQ" class="headerlink" title="FSREQ_*"></a><code>FSREQ_*</code></h3><p>file system request相关宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CREATE 8</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Fsreq"><a href="#Fsreq" class="headerlink" title="Fsreq_*"></a><code>Fsreq_*</code></h3><p>file system request相关结构体，保存相应request所需要的信息。如，open需要路径path和模式omode，所以<code>Fsreq_open</code>结构体包含了这两项内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	u_int req_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	<span class="type">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u_char req_path[MAXPATHLEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h2 id="函数和宏函数"><a href="#函数和宏函数" class="headerlink" title="函数和宏函数"></a>函数和宏函数</h2><p><img src="/2022-05-31-%E3%80%8CBUAA-OS-Lab5%E3%80%8D%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A.assets/fs%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.png" alt="fs函数调用关系"></p>
<p>这是fs相关函数的调用关系，太抽象了，难蚌。</p>
<hr>
<h3 id="read-sector"><a href="#read-sector" class="headerlink" title="read_sector"></a><code>read_sector</code></h3><p>内核态驱动，该函数为示意，不在代码中真实存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># read sector at specified offset from the beginning of the disk image. </span><br><span class="line">LEAF(read_sector)</span><br><span class="line">	sw a0, 0xB3000010 # select the IDE id. </span><br><span class="line">	sw a1, 0xB3000000 # offset.</span><br><span class="line">	li t0, 0</span><br><span class="line">	sb t0, 0xB3000020 # start read. </span><br><span class="line">	lw v0, 0xB3000030</span><br><span class="line">	nop </span><br><span class="line">	jr ra </span><br><span class="line">	nop</span><br><span class="line">END(read_sector)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sys-write-dev"><a href="#sys-write-dev" class="headerlink" title="sys_write_dev"></a><code>sys_write_dev</code></h3><p>系统调用写设备</p>
<p>位置：<code>lib/syscall_all.c</code></p>
<p><code>dev</code>意味device，设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(<span class="type">int</span> sysno, u_int va, u_int dev, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Your code here</span></span><br><span class="line">	<span class="keyword">if</span> (dev &gt;= <span class="number">0x10000000</span> &amp;&amp; dev + len &lt;= <span class="number">0x10000020</span> ||</span><br><span class="line">		dev &gt;= <span class="number">0x13000000</span> &amp;&amp; dev + len &lt;= <span class="number">0x13004200</span> ||</span><br><span class="line">		dev &gt;= <span class="number">0x15000000</span> &amp;&amp; dev + len &lt;= <span class="number">0x15000200</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		bcopy(va, <span class="number">0xa0000000</span> + dev, len);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统调用函数<code>syscall_write_dev</code>的实现，将从<code>va</code>开始长度为<code>len</code>的字节拷贝到<code>0xa000,0000 + dev</code>虚拟地址处（实际上，dev就是设备的物理地址，但得益于我们的虚拟地址机制，这里需要引用的是映射到kseg1的虚拟地址空间的地址）</p>
<hr>
<h3 id="sys-read-dev"><a href="#sys-read-dev" class="headerlink" title="sys_read_dev"></a><code>sys_read_dev</code></h3><p>系统调用读设备</p>
<p>位置：<code>lib/syscall_.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(<span class="type">int</span> sysno, u_int va, u_int dev, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Your code here</span></span><br><span class="line">	<span class="keyword">if</span> (dev &gt;= <span class="number">0x10000000</span> &amp;&amp; dev + len &lt;= <span class="number">0x10000020</span> ||</span><br><span class="line">		dev &gt;= <span class="number">0x13000000</span> &amp;&amp; dev + len &lt;= <span class="number">0x13004200</span> ||</span><br><span class="line">		dev &gt;= <span class="number">0x15000000</span> &amp;&amp; dev + len &lt;= <span class="number">0x15000200</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		bcopy(<span class="number">0xa0000000</span> + dev, va, len);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似<code>sys_write_dev</code>。</p>
<hr>
<h3 id="ide-write"><a href="#ide-write" class="headerlink" title="ide_write"></a><code>ide_write</code></h3><p>写IDE磁盘，具体地，我们依赖下图，通过在特定位置写入指定内容</p>
<p><img src="/2022-05-31-%E3%80%8CBUAA-OS-Lab5%E3%80%8D%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A.assets/image-20220601200917606.png" alt="image-20220601200917606"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *src, u_int nsecs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Your code here</span></span><br><span class="line">	<span class="type">int</span> offset_begin = secno * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> offset_now = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> op_status = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> write = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> can_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DO NOT DELETE WRITEF !!!</span></span><br><span class="line">	writef(<span class="string">&quot;diskno: %d\n&quot;</span>, diskno);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (offset_begin + offset &lt; offset_end) &#123;</span><br><span class="line">		<span class="comment">// copy data from source array to disk buffer.</span></span><br><span class="line">		offset_now = offset_begin + offset;</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;diskno, <span class="number">0x13000010</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;offset_now, <span class="number">0x13000000</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(src + offset, <span class="number">0x13004000</span>, <span class="number">0x200</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;read failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;write, <span class="number">0x13000020</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (syscall_read_dev(&amp;op_status, <span class="number">0x13000030</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (op_status == <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;read failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		offset += <span class="number">0x200</span>;</span><br><span class="line">		<span class="comment">// if error occur, then panic.</span></span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="ide-read"><a href="#ide-read" class="headerlink" title="ide_read"></a><code>ide_read</code></h3><p>读IDE磁盘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0x200: the size of a sector: 512 bytes.</span></span><br><span class="line">	<span class="type">int</span> offset_begin = secno * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	u_int zero = <span class="number">0</span>;</span><br><span class="line">	u_int cur_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> op_status = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> read = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> can_read = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (offset_begin + offset &lt; offset_end) &#123;</span><br><span class="line">		<span class="comment">// Your code here</span></span><br><span class="line">		cur_offset = offset_begin + offset; <span class="comment">// calc current offset</span></span><br><span class="line">		<span class="comment">/* set diskno */</span></span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;diskno, <span class="number">0x13000010</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* set offset */</span></span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;cur_offset, <span class="number">0x13000000</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* set value */</span></span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;read, <span class="number">0x13000020</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (syscall_read_dev(&amp;op_status, <span class="number">0x13000030</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;write failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (op_status == <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;read failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (syscall_read_dev(dst + offset, <span class="number">0x13004000</span>, <span class="number">0x200</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;read failed!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		offset += <span class="number">0x200</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// error occurred, then panic.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="init-disk"><a href="#init-disk" class="headerlink" title="init_disk"></a><code>init_disk</code></h3><p>初始化磁盘块。具体的代码含义在注释中给出</p>
<p>位置：<code>fs/fsformat.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initial the disk. Do some work with bitmap and super block.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_disk</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, r, diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Mark boot sector block.</span></span><br><span class="line">    <span class="comment">// 标记0号块为BLOCK_BOOT</span></span><br><span class="line">    disk[<span class="number">0</span>].type = BLOCK_BOOT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Initialize boundary.</span></span><br><span class="line">    <span class="comment">// 计算使用位图管理法需要多少磁盘块，这里算出来应该是1</span></span><br><span class="line">    nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">    <span class="comment">// 设置下一个空闲块为2 + nbitblock。第一个块我们为boot，第二个块为超级块，后续紧跟的nbitblock个块为bitmap位图管理用的（事实上应该是就一个块）</span></span><br><span class="line">    nextbno = <span class="number">2</span> + nbitblock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Initialize bitmap blocks.</span></span><br><span class="line">    <span class="comment">// 设置位图管理用的磁盘块</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">        disk[<span class="number">2</span>+i].type = BLOCK_BMAP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将位图管理用的磁盘块的所有位置1，表示所有块都可用</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(disk[<span class="number">2</span>+i].data, <span class="number">0xff</span>, BY2BLK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(NBLOCK != nbitblock * BIT2BLK) &#123;</span><br><span class="line">        diff = NBLOCK % BIT2BLK / <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">memset</span>(disk[<span class="number">2</span>+(nbitblock<span class="number">-1</span>)].data+diff, <span class="number">0x00</span>, BY2BLK - diff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Initialize super block.</span></span><br><span class="line">    <span class="comment">// 设置超级块</span></span><br><span class="line">    disk[<span class="number">1</span>].type = BLOCK_SUPER;</span><br><span class="line">    super.s_magic = FS_MAGIC;</span><br><span class="line">    super.s_nblocks = NBLOCK;</span><br><span class="line">    super.s_root.f_type = FTYPE_DIR;</span><br><span class="line">    <span class="built_in">strcpy</span>(super.s_root.f_name, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="write-file"><a href="#write-file" class="headerlink" title="write_file"></a><code>write_file</code></h3><p>向<code>dirf</code>下面写入<code>path</code>表示的文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_file</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line">    <span class="type">uint8_t</span> buffer[n+<span class="number">1</span>], *dist;</span><br><span class="line">    <span class="comment">// 调用creat_file，在dirf下新建一个文件索引结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* in case `create_file` is&#x27;t filled */</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(path, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get file name with no path prefix.</span></span><br><span class="line">    <span class="comment">// 获取文件名，即去掉路径中的dir/subdir/等</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fname)</span><br><span class="line">        fname++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fname = path;</span><br><span class="line">    <span class="built_in">strcpy</span>(target-&gt;f_name, fname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用lseek获取文件大小</span></span><br><span class="line">    target-&gt;f_size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="comment">// 设置文件类型为普通文件</span></span><br><span class="line">    target-&gt;f_type = FTYPE_REG;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start reading file.</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="comment">// 循环向disk[nextbno]写入内容</span></span><br><span class="line">    <span class="keyword">while</span>((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将块连接到新创建的文件中，iblk指的是文件中存在的引用指针数</span></span><br><span class="line">        save_block_link(target, iblk++, next_block(BLOCK_DATA));</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd); <span class="comment">// Close file descriptor.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="block-is-free"><a href="#block-is-free" class="headerlink" title="block_is_free"></a><code>block_is_free</code></h3><p>位置：<code>fs/fs.c</code></p>
<p>通过位图的特定位来判断指定的磁盘块是否被占用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">block_is_free</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="create-file"><a href="#create-file" class="headerlink" title="create_file"></a><code>create_file</code></h3><p>在dirf目录文件下，创建一个新的文件索引</p>
<p>位置：<code>fs/fsformat.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">### `save_block_link`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">// Save block link.</span><br><span class="line">void save_block_link(struct File *f, int nblk, int bno)</span><br><span class="line">&#123;</span><br><span class="line">    assert(nblk &lt; NINDIRECT); // if not, file is too large !</span><br><span class="line"></span><br><span class="line">    if (nblk &lt; NDIRECT)</span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;f_direct[nblk] = bno;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (f-&gt;f_indirect == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            // create new indirect block.</span><br><span class="line">            f-&gt;f_indirect = next_block(BLOCK_INDEX);</span><br><span class="line">        &#125;</span><br><span class="line">        ((uint32_t *)(disk[f-&gt;f_indirect].data))[nblk] = bno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="make-link-block"><a href="#make-link-block" class="headerlink" title="make_link_block"></a><code>make_link_block</code></h3><p>创建相邻块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make new block contians link to files in a directory.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">make_link_block</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">int</span> nblk)</span></span><br><span class="line">&#123;</span><br><span class="line">    save_block_link(dirf, nblk, nextbno);</span><br><span class="line">    dirf-&gt;f_size += BY2BLK;</span><br><span class="line">    <span class="keyword">return</span> next_block(BLOCK_FILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="flush-bitmap"><a href="#flush-bitmap" class="headerlink" title="flush_bitmap"></a><code>flush_bitmap</code></h3><p>把nextbno之前的所有块对应的bitmap标记为0，即，不可用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush disk block usage to bitmap.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flush_bitmap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// update bitmap, mark all bit where corresponding block is used.</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nextbno; ++i) &#123;</span><br><span class="line">        ((<span class="type">uint32_t</span> *)disk[<span class="number">2</span>+i/BIT2BLK].data)[(i%BIT2BLK)/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="finish-fs"><a href="#finish-fs" class="headerlink" title="finish_fs"></a><code>finish_fs</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finish all work, dump block array into physical file.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">finish_fs</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd, i, k, n, r;</span><br><span class="line">    <span class="type">uint32_t</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare super block.</span></span><br><span class="line">    <span class="comment">// 将超级块的内容拷贝到第二块block中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(disk[<span class="number">1</span>].data, &amp;super, <span class="keyword">sizeof</span>(super));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump data in `disk` to target image file.</span></span><br><span class="line">    <span class="comment">// 用open打开name问年间</span></span><br><span class="line">    fd = open(name, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 大小端转换</span></span><br><span class="line">        reverse_block(disk+i);</span><br><span class="line">        <span class="comment">// 写文件</span></span><br><span class="line">        write(fd, disk[i].data, BY2BLK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish.</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="diskaddr"><a href="#diskaddr" class="headerlink" title="diskaddr"></a><code>diskaddr</code></h3><p>根据给定磁盘块号计算对应的虚拟地址</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (super != <span class="literal">NULL</span> &amp;&amp; blockno &gt; super-&gt;s_nblocks)</span><br><span class="line">		user_panic(<span class="string">&quot;diskaddr panic&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> DISKMAP + blockno * BY2BLK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="block-is-mapped"><a href="#block-is-mapped" class="headerlink" title="block_is_mapped"></a><code>block_is_mapped</code></h3><p>判断块是否已经映射到虚拟地址了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">	u_int va = diskaddr(blockno);</span><br><span class="line">	<span class="keyword">if</span> (va_is_mapped(va))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> va;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="write-block"><a href="#write-block" class="headerlink" title="write_block"></a><code>write_block</code></h3><p>写磁盘块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_block</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: detect is this block is mapped, if not, can&#x27;t write it&#x27;s data to disk.</span></span><br><span class="line">    <span class="comment">// 判断磁盘块是否已经映射，没有映射说明错误</span></span><br><span class="line">	<span class="keyword">if</span> (!block_is_mapped(blockno))</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;write unmapped block %08x&quot;</span>, blockno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step2: write data to IDE disk. (using ide_write, and the diskno is 0)</span></span><br><span class="line">    <span class="comment">// 获取磁盘块对应的虚拟地址，将虚拟地址对应的内容写回到磁盘块</span></span><br><span class="line">	va = diskaddr(blockno);</span><br><span class="line">	ide_write(<span class="number">0</span>, blockno * SECT2BLK, (<span class="type">void</span> *)va, SECT2BLK);</span><br><span class="line"></span><br><span class="line">	syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, (PTE_V | PTE_R | PTE_LIBRARY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="map-block"><a href="#map-block" class="headerlink" title="map_block"></a><code>map_block</code></h3><p>检查指定的磁盘块是否已经映射到内存，如果没有，分配一页内存来保存磁盘上的数据</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">map_block</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: Decide whether this block has already mapped to a page of physical memory.</span></span><br><span class="line">    <span class="comment">// 根据给定磁盘块判断是否已经映射到虚拟地址了</span></span><br><span class="line">    <span class="keyword">if</span> (block_is_mapped(blockno)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有映射到虚拟地址，为blockno对应的虚拟地址分配并映射一页</span></span><br><span class="line">    <span class="comment">// Step 2: Alloc a page of memory for this block via syscall.</span></span><br><span class="line">    <span class="keyword">return</span> syscall_mem_alloc(<span class="number">0</span>, diskaddr(blockno), PTE_R | PTE_V);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="unmap-block"><a href="#unmap-block" class="headerlink" title="unmap_block"></a><code>unmap_block</code></h3><p>取消磁盘块映射</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int addr;</span><br><span class="line">    <span class="comment">// Step 1: check if this block is mapped.</span></span><br><span class="line">    <span class="comment">// 检查磁盘块是否确实已经被映射</span></span><br><span class="line">    addr = block_is_mapped(blockno);</span><br><span class="line">    <span class="comment">// Step 2: use block_is_free�~Lblock_is_dirty to check block,</span></span><br><span class="line">    <span class="comment">// if this block is used(not free) and dirty, it needs to be synced to disk: write_block</span></span><br><span class="line">    <span class="comment">// can&#x27;t be unmap directly.</span></span><br><span class="line">    <span class="comment">// 如果磁盘块非free且已经被改写过，进行写块操作</span></span><br><span class="line">    <span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">        write_block(blockno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消磁盘块对应虚拟地址的映射</span></span><br><span class="line">    <span class="comment">// Step 3: use &#x27;syscall_mem_unmap&#x27; to unmap corresponding virtual memory.</span></span><br><span class="line">    r = syscall_mem_unmap(<span class="number">0</span>, addr);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step 4: validate result of this unmap operation.</span></span><br><span class="line">    user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="va-is-mapped"><a href="#va-is-mapped" class="headerlink" title="va_is_mapped"></a><code>va_is_mapped</code></h3><p>位置：<code>fs/fs.c</code></p>
<p>判断虚拟地址是否已经映射到块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">va_is_mapped</span><span class="params">(u_int va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (((*vpd)[PDX(va)] &amp; (PTE_V)) &amp;&amp; ((*vpt)[VPN(va)] &amp; (PTE_V)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="read-block"><a href="#read-block" class="headerlink" title="read_block"></a><code>read_block</code></h3><p>读磁盘块。根据给定磁盘块号，判断该块内容是否已经在内存中，如果不在，则分配一页内存并将内容拷贝到该页。</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span> **blk, u_int *isnew)</span></span><br><span class="line">&#123;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: validate blockno. Make file the block to read is within the disk.</span></span><br><span class="line">    <span class="comment">// 检查super是否为空，非空时blockno是否超过超级块控制的上限，返回对应的错误。</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: validate this block is used, not free.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//	If the bitmap is NULL, indicate that we haven&#x27;t read bitmap from disk to memory</span></span><br><span class="line">	<span class="comment">// 	until now. So, before we check if a block is free using `block_is_free`, we must</span></span><br><span class="line">	<span class="comment">// 	ensure that the bitmap blocks are already read from the disk to memory.</span></span><br><span class="line">     <span class="comment">// 判断bitmap是否加载，接着判断该块对应是否为空块</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: transform block number to corresponding virtual address.</span></span><br><span class="line">    <span class="comment">// 调用diskaddr，将磁盘块号转为其在当前进程的虚拟地址</span></span><br><span class="line">	va = diskaddr(blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: read disk and set *isnew.</span></span><br><span class="line">	<span class="comment">// Hint: if this block is already mapped, just set *isnew, else alloc memory and</span></span><br><span class="line">	<span class="comment">// read data from IDE disk (use `syscall_mem_alloc` and `ide_read`).</span></span><br><span class="line">	<span class="comment">// We have only one IDE disk, so the diskno of ide_read should be 0.</span></span><br><span class="line">    <span class="comment">// 如果块已经映射了</span></span><br><span class="line">	<span class="keyword">if</span> (block_is_mapped(blockno))</span><br><span class="line">	&#123; <span class="comment">//the block is in memory</span></span><br><span class="line">         <span class="comment">// 如果isnew不是空指针</span></span><br><span class="line">		<span class="keyword">if</span> (isnew)</span><br><span class="line">		&#123;</span><br><span class="line">             <span class="comment">// 设置isnew为假</span></span><br><span class="line">			*isnew = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123; <span class="comment">//the block is not in memory</span></span><br><span class="line">		<span class="keyword">if</span> (isnew)</span><br><span class="line">		&#123;</span><br><span class="line">             <span class="comment">// 设置isnew为真，即，分配了新内存页</span></span><br><span class="line">			*isnew = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">// 申请一个新的页</span></span><br><span class="line">		syscall_mem_alloc(<span class="number">0</span>, va, PTE_V | PTE_R);</span><br><span class="line">         <span class="comment">// 将对应块的内容调到该页上</span></span><br><span class="line">		ide_read(<span class="number">0</span>, blockno * SECT2BLK, (<span class="type">void</span> *)va, SECT2BLK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: if blk != NULL, set `va` to *blk.</span></span><br><span class="line">     <span class="comment">// 如果blk非空，返回其在内存中挂载的位置</span></span><br><span class="line">	<span class="keyword">if</span> (blk)</span><br><span class="line">	&#123;</span><br><span class="line">		*blk = (<span class="type">void</span> *)va;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="alloc-block-num"><a href="#alloc-block-num" class="headerlink" title="alloc_block_num"></a><code>alloc_block_num</code></h3><p>检索位图bitmap寻找空块并申请，如果成功申请则返回块号，否则返回-E_NO_DISK表示块已经用完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_block_num</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> blockno;</span><br><span class="line">	<span class="comment">// walk through this bitmap, find a free one and mark it as used, then sync</span></span><br><span class="line">	<span class="comment">// this block to IDE disk (using `write_block`) from memory.</span></span><br><span class="line">	<span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>)))</span><br><span class="line">		&#123; <span class="comment">//the block is free</span></span><br><span class="line">			bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">			write_block(blockno / BIT2BLK); <span class="comment">// write to disk.</span></span><br><span class="line">			<span class="keyword">return</span> blockno;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// no free blocks.</span></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="alloc-block"><a href="#alloc-block" class="headerlink" title="alloc_block"></a><code>alloc_block</code></h3><p>申请一个新的block并返回块号</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r, bno;</span><br><span class="line">	<span class="comment">// Step 1: find a free block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123; <span class="comment">// failed.</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	bno = r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: map this block into memory.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		free_block(bno);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: return block number.</span></span><br><span class="line">	<span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="file-block-walk"><a href="#file-block-walk" class="headerlink" title="file_block_walk"></a><code>file_block_walk</code></h3><p>在一个File索引中，找到<code>filebno</code>对应的索引指针</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int **ppdiskbno, u_int alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int *ptr;</span><br><span class="line">	<span class="type">void</span> *blk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; NDIRECT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Step 1: if the target block is corresponded to a direct pointer, just return the</span></span><br><span class="line">		<span class="comment">// 	disk block number.</span></span><br><span class="line">         <span class="comment">// 如果索引号小于最大直接指针数量，可以直接返回</span></span><br><span class="line">		ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Step 2: if the target block is corresponded to the indirect block, but there&#x27;s no</span></span><br><span class="line">		<span class="comment">//	indirect block and `alloc` is set, create the indirect block.</span></span><br><span class="line">        <span class="comment">// 如果索引号大于10，说明需要检索间接索引</span></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">             <span class="comment">// 间接索引块不存在</span></span><br><span class="line">			<span class="keyword">if</span> (alloc == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">                 <span class="comment">// 索引块不存在并且参数表示不允许创建一个新块，返回错误值。</span></span><br><span class="line">				<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 试图分配一个间接索引块</span></span><br><span class="line">			<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">			f-&gt;f_indirect = r;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Step 3: read the new indirect block to memory.</span></span><br><span class="line">         <span class="comment">// 读取对应的磁盘块</span></span><br><span class="line">		<span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">// 设置索引指针。这里再次强调，我们的间接索引块的前十个索引是空的，因此直接使用filbno作为偏移即可</span></span><br><span class="line">		ptr = (u_int *)blk + filebno;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置索引指针</span></span><br><span class="line">	<span class="comment">// Step 4: store the result into *ppdiskbno, and return 0.</span></span><br><span class="line">	*ppdiskbno = ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="file-map-block"><a href="#file-map-block" class="headerlink" title="file_map_block"></a><code>file_map_block</code></h3><p>找到文件对应的索引块的磁盘号，如果索引块不存在，根据<code>alloc</code>参数，决定是否创建一个新的块。</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试寻找文件索引内部对应编号的索引指针</span></span><br><span class="line">	<span class="comment">// Step 1: find the pointer for the target block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果索引指针为空，并且alloc有效，分配一个新的block</span></span><br><span class="line">	<span class="comment">// Step 2: if the block not exists, and create is set, alloc one.</span></span><br><span class="line">	<span class="keyword">if</span> (*ptr == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (alloc == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		*ptr = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: set the pointer to the block in *diskbno and return 0.</span></span><br><span class="line">	*diskbno = *ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="file-get-block"><a href="#file-get-block" class="headerlink" title="file_get_block"></a><code>file_get_block</code></h3><p>获取指定文件对应的磁盘块，并将其读入内存</p>
<p>位置：<code>fs/fs.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">void</span> **blk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int diskbno;</span><br><span class="line">	u_int isnew;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: find the disk block number is `f` using `file_map_block`.</span></span><br><span class="line">     <span class="comment">// 找到文件对应的索引块并读入内存</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: read the data in this disk to blk.</span></span><br><span class="line">    <span class="comment">// 将指定磁盘块的内容读到内存中</span></span><br><span class="line">	<span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="dir-lookup"><a href="#dir-lookup" class="headerlink" title="dir_lookup"></a><code>dir_lookup</code></h3><hr>
<h3 id="INDEX2FD"><a href="#INDEX2FD" class="headerlink" title="INDEX2FD"></a><code>INDEX2FD</code></h3><p>根据给定的fd，找到其对应的页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i)*BY2PG)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="fd-alloc"><a href="#fd-alloc" class="headerlink" title="fd_alloc"></a><code>fd_alloc</code></h3><p>申请一个文件控制符<code>fd</code></p>
<p>位置：<code>user/file.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_alloc</span><span class="params">(<span class="keyword">struct</span> Fd **fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Find the smallest i from 0 to MAXFD-1 that doesn&#x27;t have</span></span><br><span class="line">	<span class="comment">// its fd page mapped.  Set *fd to the fd page virtual address.</span></span><br><span class="line">	<span class="comment">// (Do not allocate a page.  It is up to the caller to allocate</span></span><br><span class="line">	<span class="comment">// the page.  This means that if someone calls fd_alloc twice</span></span><br><span class="line">	<span class="comment">// in a row without allocating the first page we return, we&#x27;ll</span></span><br><span class="line">	<span class="comment">// return the same page the second time.)</span></span><br><span class="line">	<span class="comment">// Return 0 on success, or an error code on error.</span></span><br><span class="line">	u_int va;</span><br><span class="line">	u_int fdno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从低至高遍历文件控制符，查找其中最小的没有被映射的fd</span></span><br><span class="line">	<span class="keyword">for</span> (fdno = <span class="number">0</span>; fdno &lt; MAXFD - <span class="number">1</span>; fdno++)</span><br><span class="line">	&#123;</span><br><span class="line">         <span class="comment">// 转换为其对应的虚拟地址</span></span><br><span class="line">		va = INDEX2FD(fdno);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有效位为0，说明无效，说明这是个可以使用的fd</span></span><br><span class="line">		<span class="keyword">if</span> (((*vpd)[va / PDMAP] &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">         <span class="comment">// 有效位为0，说明无效，说明这是个可使用的fd</span></span><br><span class="line">		<span class="keyword">if</span> (((*vpt)[va / BY2PG] &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">		&#123; <span class="comment">//the fd is not used</span></span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 上述两层判断，含义为只要vpd和vpt有一个无效，就说明无效，就说明fd可用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到空闲的fd，说明打开文件数量达到上限</span></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="fsipc-open"><a href="#fsipc-open" class="headerlink" title="fsipc_open"></a><code>fsipc_open</code></h3><p>file send ipc open，利用ipc机制发送open的相关信息，包括路径path，模式omode等</p>
<p>位置：<code>user/fsipc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Send file-open request to the file server. Includes path and</span></span><br><span class="line"><span class="comment">//	omode in request, sets *fileid and *size from reply.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//	0 on success,</span></span><br><span class="line"><span class="comment">//	&lt; 0 on failure.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int omode, <span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_open *)fsipcbuf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The path is too long.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	req-&gt;req_omode = omode;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_OPEN, req, (u_int)fd, &amp;perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="fsipc"><a href="#fsipc" class="headerlink" title="fsipc"></a><code>fsipc</code></h3><p>file system ipc，文件系统ipc</p>
<p>位置：<code>user/fsipc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type是FSREQ_*定义中的一种，fsreq传递了Fereq_*结构体对象</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, u_int dstva, u_int *perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	u_int whom;</span><br><span class="line">	<span class="comment">// NOTEICE: Our file system no.1 process!</span></span><br><span class="line">	ipc_send(envs[<span class="number">1</span>].env_id, type, (u_int)fsreq, PTE_V | PTE_R);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="fd2data"><a href="#fd2data" class="headerlink" title="fd2data"></a><code>fd2data</code></h3><p>位置：<code>user/fd.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">fd2data</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> INDEX2DATA(fd2num(fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="fd2name"><a href="#fd2name" class="headerlink" title="fd2name"></a><code>fd2name</code></h3><p>得到文件描述符的编号</p>
<p>位置：<code>user/fd.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd2num</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((u_int)fd - FDTABLE) / BY2PG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="INDEX2DATA"><a href="#INDEX2DATA" class="headerlink" title="INDEX2DATA"></a><code>INDEX2DATA</code></h3><p>位置：<code>user/fd.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i)*PDMAP)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a><code>open</code></h3><p>打开文件</p>
<p>位置：<code>user/file.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Open a file (or directory).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//	the file descriptor onsuccess,</span></span><br><span class="line"><span class="comment">//	&lt; 0 on failure.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int size, fileid;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	u_int i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Alloc a new Fd, return error code when fail to alloc.</span></span><br><span class="line">	<span class="comment">// Hint: Please use fd_alloc.</span></span><br><span class="line">    <span class="comment">// 申请一个新的文件描述符fd</span></span><br><span class="line">	r = fd_alloc(&amp;fd);</span><br><span class="line">	<span class="keyword">if</span> (r)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Get the file descriptor of the file to open.</span></span><br><span class="line">	<span class="comment">// Hint: Read fsipc.c, and choose a function.</span></span><br><span class="line">    <span class="comment">// 根据给定路径和模式发送打开文件的ipc</span></span><br><span class="line">	r = fsipc_open(path, mode, fd);</span><br><span class="line">	<span class="keyword">if</span> (r)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: Set the start address storing the file&#x27;s content. Set size and fileid correctly.</span></span><br><span class="line">	<span class="comment">// Hint: Use fd2data to get the start address.</span></span><br><span class="line">    <span class="comment">// 根据文件内容设置起始地址</span></span><br><span class="line">	va = fd2data(fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: Alloc memory, map the file content into memory.</span></span><br><span class="line">    <span class="comment">// 申请空间并映射文件内容</span></span><br><span class="line">	ffd = fd;</span><br><span class="line">	size = ffd-&gt;f_file.f_size;</span><br><span class="line">	fileid = ffd-&gt;f_fileid;</span><br><span class="line">	<span class="comment">// Step 5: Return the number of file descriptor.</span></span><br><span class="line">    <span class="comment">// 返回文件描述符</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += BY2PG)</span><br><span class="line">	&#123;</span><br><span class="line">		r = syscall_mem_alloc(<span class="number">0</span>, va + i, PTE_R | PTE_V);</span><br><span class="line">		<span class="keyword">if</span> (r)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		r = fsipc_map(fileid, i, va + i);</span><br><span class="line">		<span class="keyword">if</span> (r)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> fdnum = fd2num(fd);</span><br><span class="line">	<span class="keyword">if</span> (mode &amp; O_APPND)</span><br><span class="line">		seek(fdnum, size);</span><br><span class="line">	<span class="keyword">return</span> fdnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="fd-lookup"><a href="#fd-lookup" class="headerlink" title="fd_lookup"></a><code>fd_lookup</code></h3><p>根据给定文件控制符编号fdnum查找fd</p>
<p>位置：<code>user/fd.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_lookup</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Fd **fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Check that fdnum is in range and mapped.  If not, return -E_INVAL.</span></span><br><span class="line">	<span class="comment">// Set *fd to the fd page virtual address.  Return 0.</span></span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小超过文件控制符数量上限说明错误</span></span><br><span class="line">	<span class="keyword">if</span> (fdnum &gt;= MAXFD)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	va = INDEX2FD(fdnum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((*vpt)[va / BY2PG] &amp; PTE_V) != <span class="number">0</span>)</span><br><span class="line">	&#123; <span class="comment">//the fd is used</span></span><br><span class="line">        <span class="comment">// 有效</span></span><br><span class="line">		*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="dev-lookup"><a href="#dev-lookup" class="headerlink" title="dev_lookup"></a><code>dev_lookup</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_lookup</span><span class="params">(<span class="type">int</span> dev_id, <span class="keyword">struct</span> Dev **dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; devtab[i]; i++)</span><br><span class="line">		<span class="keyword">if</span> (devtab[i]-&gt;dev_id == dev_id)</span><br><span class="line">		&#123;</span><br><span class="line">			*dev = devtab[i];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	writef(<span class="string">&quot;[%08x] unknown device type %d\n&quot;</span>, env-&gt;env_id, dev_id);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a><code>write</code></h3><p>写文件</p>
<p>位置：<code>user/fd.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">const</span> <span class="type">void</span> *buf, u_int n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找文件描述符</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span> || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_RDONLY)</span><br><span class="line">	&#123;</span><br><span class="line">		writef(<span class="string">&quot;[%08x] write %d -- bad mode\n&quot;</span>, env-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		writef(<span class="string">&quot;write %d %p %d via dev %s\n&quot;</span>,</span><br><span class="line">			   fdnum, buf, n, dev-&gt;dev_name);</span><br><span class="line"></span><br><span class="line">	r = (*dev-&gt;dev_write)(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="fsformat-c"><a href="#fsformat-c" class="headerlink" title="fsformat.c"></a><code>fsformat.c</code></h3><p>位置：<code>fs</code></p>
<p>从本文件<code>#include &lt;stdio.h&gt;</code>可以知道，这是一个运行在Linux上的程序。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2022/06/19/Mermaid笔记/" data-toggle="tooltip" data-placement="top" title="Mermaid笔记">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2022/05/31/「BUAA-OO-Unit-3-HW12」第三单元总结/" data-toggle="tooltip" data-placement="top" title="「BUAA OO Unit 3 HW12」第三单元总结">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <hr>
                <div id="blog_comments"></div>

<!--
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
-->
<!--
<link rel="stylesheet" href="/css/gitment.css">
<script type="text/javascript" src="/js/gitment.js"></script>
-->

<script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/>

<!--
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
-->

<script>
const myTheme = {
  render(state, instance) {
    const container = document.createElement('div')
    container.lang = "en-US"
    container.className = 'gitment-container gitment-root-container'
    
     // your custom component
    container.appendChild(instance.renderSomething(state, instance))
    
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    //container.appendChild(instance.renderFooter(state, instance))
    return container
  },
  renderSomething(state, instance) {
    const container = document.createElement('div')
    container.lang = "en-US"
    container.className = 'hello_visitor'
    if (state.user.login) {
      container.innerText = `Hello ${state.user.login}, Welcome to comment system`
    }
    return container
  }
}


const gitment = new Gitment({
    id: 'Tue May 31 2022 23:27:07 GMT+0800', // optional
    owner: "saltyfishyjk",
    repo: "saltyfishyjk.github.io",
    oauth: {
      client_id: "17737ec06ef80355865e",
      client_secret: "d79eba1e32e61803f07e93646964a7978e09f515",
    },
    theme: myTheme,
    // ...
    // For more available options, check out the documentation below
  })
  
  gitment.render('blog_comments')
  // or
  // gitment.render(document.getElementById('comments'))
  // or
  // document.body.appendChild(gitment.render())
</script>
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E3%80%8CBUAA-OS-Lab5%E3%80%8D%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">「BUAA OS Lab5」名词解释</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">变量和类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Block"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">Block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#disk"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">disk</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Super"><span class="toc-nav-number">1.1.3.</span> <span class="toc-nav-text">Super</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#super"><span class="toc-nav-number">1.1.4.</span> <span class="toc-nav-text">super</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#nextbno"><span class="toc-nav-number">1.1.5.</span> <span class="toc-nav-text">nextbno</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#nbitblock"><span class="toc-nav-number">1.1.6.</span> <span class="toc-nav-text">nbitblock</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#NBLOCK"><span class="toc-nav-number">1.1.7.</span> <span class="toc-nav-text">NBLOCK</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#BY2BLK"><span class="toc-nav-number">1.1.8.</span> <span class="toc-nav-text">BY2BLK</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#BIT2BLK"><span class="toc-nav-number">1.1.9.</span> <span class="toc-nav-text">BIT2BLK</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FILE2BLK"><span class="toc-nav-number">1.1.10.</span> <span class="toc-nav-text">FILE2BLK</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#MAXNAMELEN"><span class="toc-nav-number">1.1.11.</span> <span class="toc-nav-text">MAXNAMELEN</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#MAXPATHLEN"><span class="toc-nav-number">1.1.12.</span> <span class="toc-nav-text">MAXPATHLEN</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#NDIRECT"><span class="toc-nav-number">1.1.13.</span> <span class="toc-nav-text">NDIRECT</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#NINDIRECT"><span class="toc-nav-number">1.1.14.</span> <span class="toc-nav-text">NINDIRECT</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FTYPE-REG"><span class="toc-nav-number">1.1.15.</span> <span class="toc-nav-text">FTYPE_REG</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FTYPE-DIR"><span class="toc-nav-number">1.1.16.</span> <span class="toc-nav-text">FTYPE_DIR</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FTYPE-BIN"><span class="toc-nav-number">1.1.17.</span> <span class="toc-nav-text">FTYPE_BIN</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#File"><span class="toc-nav-number">1.1.18.</span> <span class="toc-nav-text">File</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FS-MAGIC"><span class="toc-nav-number">1.1.19.</span> <span class="toc-nav-text">FS_MAGIC</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#DISKMAP"><span class="toc-nav-number">1.1.20.</span> <span class="toc-nav-text">DISKMAP</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#DISKMAX"><span class="toc-nav-number">1.1.21.</span> <span class="toc-nav-text">DISKMAX</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Fd"><span class="toc-nav-number">1.1.22.</span> <span class="toc-nav-text">Fd</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Filefd"><span class="toc-nav-number">1.1.23.</span> <span class="toc-nav-text">Filefd</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#MAXFD"><span class="toc-nav-number">1.1.24.</span> <span class="toc-nav-text">MAXFD</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FILEBASE"><span class="toc-nav-number">1.1.25.</span> <span class="toc-nav-text">FILEBASE</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FDTABLE"><span class="toc-nav-number">1.1.26.</span> <span class="toc-nav-text">FDTABLE</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#FSREQ"><span class="toc-nav-number">1.1.27.</span> <span class="toc-nav-text">FSREQ_*</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Fsreq"><span class="toc-nav-number">1.1.28.</span> <span class="toc-nav-text">Fsreq_*</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">函数和宏函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#read-sector"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">read_sector</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sys-write-dev"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">sys_write_dev</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sys-read-dev"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">sys_read_dev</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ide-write"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">ide_write</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ide-read"><span class="toc-nav-number">1.2.5.</span> <span class="toc-nav-text">ide_read</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#init-disk"><span class="toc-nav-number">1.2.6.</span> <span class="toc-nav-text">init_disk</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#write-file"><span class="toc-nav-number">1.2.7.</span> <span class="toc-nav-text">write_file</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#block-is-free"><span class="toc-nav-number">1.2.8.</span> <span class="toc-nav-text">block_is_free</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#create-file"><span class="toc-nav-number">1.2.9.</span> <span class="toc-nav-text">create_file</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#make-link-block"><span class="toc-nav-number">1.2.10.</span> <span class="toc-nav-text">make_link_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#flush-bitmap"><span class="toc-nav-number">1.2.11.</span> <span class="toc-nav-text">flush_bitmap</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#finish-fs"><span class="toc-nav-number">1.2.12.</span> <span class="toc-nav-text">finish_fs</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#diskaddr"><span class="toc-nav-number">1.2.13.</span> <span class="toc-nav-text">diskaddr</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#block-is-mapped"><span class="toc-nav-number">1.2.14.</span> <span class="toc-nav-text">block_is_mapped</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#write-block"><span class="toc-nav-number">1.2.15.</span> <span class="toc-nav-text">write_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#map-block"><span class="toc-nav-number">1.2.16.</span> <span class="toc-nav-text">map_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#unmap-block"><span class="toc-nav-number">1.2.17.</span> <span class="toc-nav-text">unmap_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#va-is-mapped"><span class="toc-nav-number">1.2.18.</span> <span class="toc-nav-text">va_is_mapped</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#read-block"><span class="toc-nav-number">1.2.19.</span> <span class="toc-nav-text">read_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#alloc-block-num"><span class="toc-nav-number">1.2.20.</span> <span class="toc-nav-text">alloc_block_num</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#alloc-block"><span class="toc-nav-number">1.2.21.</span> <span class="toc-nav-text">alloc_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#file-block-walk"><span class="toc-nav-number">1.2.22.</span> <span class="toc-nav-text">file_block_walk</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#file-map-block"><span class="toc-nav-number">1.2.23.</span> <span class="toc-nav-text">file_map_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#file-get-block"><span class="toc-nav-number">1.2.24.</span> <span class="toc-nav-text">file_get_block</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#dir-lookup"><span class="toc-nav-number">1.2.25.</span> <span class="toc-nav-text">dir_lookup</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#INDEX2FD"><span class="toc-nav-number">1.2.26.</span> <span class="toc-nav-text">INDEX2FD</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fd-alloc"><span class="toc-nav-number">1.2.27.</span> <span class="toc-nav-text">fd_alloc</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fsipc-open"><span class="toc-nav-number">1.2.28.</span> <span class="toc-nav-text">fsipc_open</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fsipc"><span class="toc-nav-number">1.2.29.</span> <span class="toc-nav-text">fsipc</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fd2data"><span class="toc-nav-number">1.2.30.</span> <span class="toc-nav-text">fd2data</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fd2name"><span class="toc-nav-number">1.2.31.</span> <span class="toc-nav-text">fd2name</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#INDEX2DATA"><span class="toc-nav-number">1.2.32.</span> <span class="toc-nav-text">INDEX2DATA</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#open"><span class="toc-nav-number">1.2.33.</span> <span class="toc-nav-text">open</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fd-lookup"><span class="toc-nav-number">1.2.34.</span> <span class="toc-nav-text">fd_lookup</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#dev-lookup"><span class="toc-nav-number">1.2.35.</span> <span class="toc-nav-text">dev_lookup</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#write"><span class="toc-nav-number">1.2.36.</span> <span class="toc-nav-text">write</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">文件</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fsformat-c"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">fsformat.c</span></a></li></ol></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#BUAA-OS" title="BUAA-OS">BUAA-OS</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://thysrael.github.io/" target="_blank">Thysrael</a></li>
                    
                        <li><a href="https://wxx0105.cn/" target="_blank">贤弟安全</a></li>
                    
                        <li><a href="https://iszry.github.io" target="_blank">Matcha Flavor</a></li>
                    
                        <li><a href="https://master-tan.github.io/" target="_blank">Tan&#39;s Blog</a></li>
                    
                        <li><a href="https://mksasx.github.io/" target="_blank">AustinMa</a></li>
                    
                        <li><a href="https://bluebean-cloud.github.io/" target="_blank">Bluebean</a></li>
                    
                        <li><a href="https://chlience.cn/" target="_blank">Chlience</a></li>
                    
                        <li><a href="https://sunnyduan-oss.github.io/" target="_blank">甜胖妮</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/saltyfishyjk">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/gu-long-mo-yu">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; saltyfishyjk 2025 
                    <br>
                    Powered by 
                    <a href="https://github.com/saltyfishyjk/saltyfishyjk.github.io">
                        <i>saltyfishyjk</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=saltyfishyjk&repo=saltyfishyjk.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://saltyfishyjk.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&#34;🐟&#34;]' color='[&#34;rgb(121,93,179)&#34; ,&#34;rgb(76,180,231)&#34;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
</body>

</html>
